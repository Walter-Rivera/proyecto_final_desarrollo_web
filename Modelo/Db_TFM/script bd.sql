/*Creando tablas con solo llave primaria
EL sigueinte DDL estará orientado a una base de datos
mysql

Restricciones:
1.- El nombre de las llaves primarias irá compuesto por las iniciales
de cada palabra del nombre de la tabla
    * Se es primaria se agregará al inicio PK_
    *SI es foránea se agregará al inicio FK_
    *Si es una llave primaria compuesta, se agregará al inicio PKC_
    *Si es una llave foránea compuesta, se agregará al inici FKC_.

*/

CREATE TABLE ESTADO_PERITO
(
    ID_ESTADO_PERITO INT(3),
    NOMBRE VARCHAR(100)
);

/*AGREGANDO LLAVE PRIMARIA*/
ALTER TABLE ESTADO_PERITO ADD CONSTRAINT PK_EP PRIMARY KEY(ID_ESTADO_PERITO);
/*VOLVIENDO LA LLAVE PRIMARIA COMO CAMPO AUTOINCREMENTABLE*/
ALTER TABLE ESTADO_PERITO MODIFY COLUMN ID_ESTADO_PERITO INT(3) AUTO_INCREMENT;


/*tabla tipo_movimiento_usuario:*/
CREATE TABLE TIPO_MOVIMIENTO_USUARIO
(
    ID_TIPO_MOVIMIENTO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE TIPO_MOVIMIENTO_USUARIO ADD CONSTRAINT PK_TMU PRIMARY KEY(ID_TIPO_MOVIMIENTO);
ALTER TABLE TIPO_MOVIMIENTO_USUARIO MODIFY COLUMN ID_TIPO_MOVIMIENTO INT(3) AUTO_INCREMENT;

CREATE TABLE CAMPO_AFECTADO_USUARIO
(
    ID_CAMPO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE CAMPO_AFECTADO_USUARIO ADD CONSTRAINT PK_CAU PRIMARY KEY(ID_CAMPO);
ALTER TABLE CAMPO_AFECTADO_USUARIO MODIFY COLUMN ID_CAMPO INT(3) AUTO_INCREMENT;



CREATE TABLE TIPO_MOVIMIENTO_PERITO
(
    ID_TIPO_MOVIMIENTO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE TIPO_MOVIMIENTO_PERITO ADD CONSTRAINT PK_PER PRIMARY KEY(ID_TIPO_MOVIMIENTO);
ALTER TABLE TIPO_MOVIMIENTO_PERITO MODIFY COLUMN ID_TIPO_MOVIMIENTO INT(3) AUTO_INCREMENT;

CREATE TABLE CAMPO_AFECTADO_PERITO
(
    ID_CAMPO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE CAMPO_AFECTADO_PERITO ADD CONSTRAINT PK_CAFPER PRIMARY KEY(ID_CAMPO);
ALTER TABLE CAMPO_AFECTADO_PERITO MODIFY COLUMN ID_CAMPO INT(3) AUTO_INCREMENT;





CREATE TABLE TIPO_MOVIMIENTO_TIPO_GESTION
(
    ID_TIPO_MOVIMIENTO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE TIPO_MOVIMIENTO_TIPO_GESTION ADD CONSTRAINT PK_TMTG PRIMARY KEY(ID_TIPO_MOVIMIENTO);
ALTER TABLE TIPO_MOVIMIENTO_TIPO_GESTION MODIFY COLUMN ID_TIPO_MOVIMIENTO INT(3) AUTO_INCREMENT;

CREATE TABLE CAMPO_AFECTADO_TIPO_GESTION
(
    ID_CAMPO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE CAMPO_AFECTADO_TIPO_GESTION ADD CONSTRAINT PK_CAFTGES PRIMARY KEY(ID_CAMPO);
ALTER TABLE CAMPO_AFECTADO_TIPO_GESTION MODIFY COLUMN ID_CAMPO INT(3) AUTO_INCREMENT;











/*tabla TIPO_MOVIMIENTO_SECCION: contiene la definición de acciones sobre la tabla seccion siendo 
inserción, actualización y baja(no hacer visible los datos al usuario en el frontend)*/
CREATE TABLE TIPO_MOVIMIENTO_SECCION
(
    ID_TIPO_MOVIMIENTO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE TIPO_MOVIMIENTO_SECCION ADD CONSTRAINT PK_TMSEC PRIMARY KEY(ID_TIPO_MOVIMIENTO);
ALTER TABLE TIPO_MOVIMIENTO_SECCION MODIFY COLUMN ID_TIPO_MOVIMIENTO INT(3) AUTO_INCREMENT;


/*tabla CAMPO_AFECTADO_SECCION: Poseerá dentro de las tuplas que albergue, los nombres correspondientes
de cada campo de la tabla seccion, esto a fin de registrar en la bitácora cual campo fue afectado 
por una acción del usuario en el crud (creación, actualización ,"borrado->baja")*/
CREATE TABLE CAMPO_AFECTADO_SECCION
(
    ID_CAMPO INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE CAMPO_AFECTADO_SECCION ADD CONSTRAINT PK_CASEC PRIMARY KEY(ID_CAMPO);
ALTER TABLE CAMPO_AFECTADO_SECCION MODIFY COLUMN ID_CAMPO INT(3) AUTO_INCREMENT;


/*UNA SECCIÓN PODRÁ ESTAR ACTIVA O DE BAJA, MAS NO INACTIVA*/
CREATE TABLE ESTADO_SECCION
(
    ID_ESTADO_SECCION INT(3),
    NOMBRE VARCHAR(100)
);
ALTER TABLE ESTADO_SECCION ADD CONSTRAINT PK_ESEC PRIMARY KEY(ID_ESTADO_SECCION);
ALTER TABLE ESTADO_SECCION MODIFY COLUMN ID_ESTADO_SECCION INT(3) AUTO_INCREMENT;


CREATE TABLE ESTADO_GESTION
(
    ID_ESTADO_GESTION INT(3),
    NOMBRE VARCHAR(100)
);
ALTER TABLE ESTADO_GESTION ADD CONSTRAINT PK_EG PRIMARY KEY(ID_ESTADO_GESTION);
ALTER TABLE ESTADO_GESTION MODIFY COLUMN ID_ESTADO_GESTION INT(3) AUTO_INCREMENT;



CREATE TABLE TIPO_MOVIMIENTO_GESTION
(
    ID_TIPO_MOV INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE TIPO_MOVIMIENTO_GESTION ADD CONSTRAINT PK_TMG PRIMARY KEY(ID_TIPO_MOV);
ALTER TABLE TIPO_MOVIMIENTO_GESTION MODIFY COLUMN ID_TIPO_MOV INT(3) AUTO_INCREMENT;




CREATE TABLE CAMPO_AFECTADO_GESTION
(
    ID_CAMPO INT(3),
    NOMBRE VARCHAR(100)
);
ALTER TABLE CAMPO_AFECTADO_GESTION ADD CONSTRAINT PK_CAG PRIMARY KEY(ID_CAMPO);
ALTER TABLE CAMPO_AFECTADO_GESTION MODIFY COLUMN ID_CAMPO INT(3) AUTO_INCREMENT;




CREATE TABLE ESTADO_USUARIO
(
    ID_ESTADO_USR INT(3),
    NOMBRE VARCHAR(100)
);
ALTER TABLE ESTADO_USUARIO ADD CONSTRAINT PK_EU PRIMARY KEY(ID_ESTADO_USR);
ALTER TABLE ESTADO_USUARIO MODIFY COLUMN ID_ESTADO_USR INT(3) AUTO_INCREMENT;





CREATE TABLE ESTADO_TIPO_GESTION
(
    ID_ESTADO_TIPO_GESTION INT(3),
    NOMBRE VARCHAR(100)
);
/*AGREGANDO LLAVE PRIMARIA*/
ALTER TABLE ESTADO_TIPO_GESTION ADD CONSTRAINT PK_ETGEST PRIMARY KEY(ID_ESTADO_TIPO_GESTION);
/*VOLVIENDO LA LLAVE PRIMARIA COMO CAMPO AUTOINCREMENTABLE*/
ALTER TABLE ESTADO_TIPO_GESTION MODIFY COLUMN ID_ESTADO_TIPO_GESTION INT(3) AUTO_INCREMENT;




/*ROL_USUARIO: Contendrá en su definición, los roles necesarios en el sistema,
de momento se definieron 3 principales siendo:
*Administrador
*Jefatura
*Auxiliar_Administrativo*/

CREATE TABLE ROL_USUARIO
(
    ID_ROL INT(3),
    DESCRIPCION VARCHAR(100)
);
ALTER TABLE ROL_USUARIO ADD CONSTRAINT PK_RU PRIMARY KEY(ID_ROL);
ALTER TABLE ROL_USUARIO MODIFY COLUMN ID_ROL INT(3) AUTO_INCREMENT;




CREATE TABLE SECCION
(
    ID_SECCION INT(3),
    NOMBRE VARCHAR(100),
    IDENTIFICADOR VARCHAR(10),
    ULTIMO_USUARIO_MODIFICADOR INT(6),
    ID_ESTADO_SECCION INT(3)
);
ALTER TABLE SECCION ADD CONSTRAINT PK_SEC PRIMARY KEY(ID_SECCION);
ALTER TABLE SECCION MODIFY COLUMN ID_SECCION INT(3) AUTO_INCREMENT;
ALTER TABLE SECCION ADD CONSTRAINT FK_UUMO FOREIGN KEY(ULTIMO_USUARIO_MODIFICADOR)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);
ALTER TABLE SECCION ADD CONSTRAINT FK_IESECC FOREIGN KEY(ID_ESTADO_SECCION)
REFERENCES ESTADO_SECCION(ID_ESTADO_SECCION);

CREATE TABLE CLASE_GESTION
(
    ID_CLASE_GESTION INT(3),
    NOMBRE VARCHAR(100)
);
ALTER TABLE CLASE_GESTION ADD CONSTRAINT PK_CS PRIMARY KEY(ID_CLASE_GESTION);
ALTER TABLE CLASE_GESTION MODIFY COLUMN ID_CLASE_GESTION INT(3) AUTO_INCREMENT;



/*en esta parte inician las tables con llaves primareas y foráneas*/


/* En el caso de la tabla PERITO, no se definirá como autoincrementable
el campo del id_perito, a causa que este número será el Número de Identificación
Personal (NIP) que posee cada colaborador el cual es designado por la unidad
de Recrusos humanos*/
CREATE TABLE PERITO
(
    ID_PERITO INT(6),
    NOMBRES VARCHAR(200),
    APELLIDOS VARCHAR(100),
    FECHA_CREACION TIMESTAMP,
    ID_ESTADO_PERITO INT(3),
    ULTIMO_USUARIO_MODIFICADOR INT(6)
);
ALTER TABLE PERITO ADD CONSTRAINT PK_PER PRIMARY KEY(ID_PERITO);
ALTER TABLE PERITO ADD CONSTRAINT FK_EP FOREIGN KEY(ID_ESTADO_PERITO) 
REFERENCES ESTADO_PERITO(ID_ESTADO_PERITO);
ALTER TABLE PERITO ADD CONSTRAINT FK_IDULTMODF FOREIGN KEY(ULTIMO_USUARIO_MODIFICADOR)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);


/*al igual que la tabla PERITO, la tabla USUARIO_SISTEMA
no poseerá en su id de llave primaria la característica de ser 
autoncrementable, pues el ID_USUARIO será ingresado conforme 
la asignación del NIP (Número de identifiacción Personal) 
al personal

El campo de contraseña (acceso) será encriptado posteriormente
cuando se inserten los datos a traves del algoritmo y funcion
que dota mysql SHA*
*/
CREATE TABLE USUARIO_SISTEMA
(
    ID_USUARIO INT(6),
    NOMBRES VARCHAR(200),
    APELLIDOS VARCHAR(100),
    ID_ESTADO_USR INT(3),
    ID_ROL INT(3),
    ACCESO VARCHAR(200),
    ULTIMO_LOGIN TIMESTAMP,
    ULTIMO_USUARIO_MODIFICADOR INT(6)
);
ALTER TABLE USUARIO_SISTEMA ADD CONSTRAINT PK_US PRIMARY KEY(ID_USUARIO);
ALTER TABLE USUARIO_SISTEMA ADD CONSTRAINT FK_IEU FOREIGN KEY(ID_ESTADO_USR)
REFERENCES ESTADO_USUARIO(ID_ESTADO_USR);
ALTER TABLE USUARIO_SISTEMA ADD CONSTRAINT FK_IDR FOREIGN KEY(ID_ROL)
REFERENCES ROL_USUARIO(ID_ROL);
ALTER TABLE USUARIO_SISTEMA ADD CONSTRAINT FK_URMOD FOREIGN KEY(ULTIMO_USUARIO_MODIFICADOR)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);


/*Esta tabla tendrá los datos correspondientes a los tipos de gestiones que se manejan en
Tanatología Forense Metropolitana siendo:
o   Necropsia.
o	Ampliación.
o	Rectificación.
o	Reiteración de orden.
o	Búsqueda de personas desaparecidas.
o	Correlaciones de expedientes clínicos y necropsias.
o	Citaciones a debates (presenciales o videoconferencias).
o	Respuesta Administrativa (por parte de Jefatura de Tanatología Forense).
o	SG(Asistencias Judiciales).

*/
CREATE TABLE TIPO_GESTION
(
    ID_TIPO_GESTION INT(3),
    NOMBRE VARCHAR(100),
    ID_CLASE_GESTION INT(3),
    ID_ESTADO_TIPO_GESTION INT(3),
    ULTIMO_USUARIO_MODIFICADOR INT(6) 
);
ALTER TABLE TIPO_GESTION ADD CONSTRAINT PK_TG PRIMARY KEY(ID_TIPO_GESTION);
ALTER TABLE TIPO_GESTION MODIFY COLUMN ID_TIPO_GESTION INT(3) AUTO_INCREMENT;
ALTER TABLE TIPO_GESTION ADD CONSTRAINT FK_ICG FOREIGN KEY(ID_CLASE_GESTION)
REFERENCES CLASE_GESTION(ID_CLASE_GESTION);
ALTER TABLE TIPO_GESTION ADD CONSTRAINT FK_IESTGEST FOREIGN KEY(ID_ESTADO_TIPO_GESTION)
REFERENCES ESTADO_TIPO_GESTION(ID_ESTADO_TIPO_GESTION);
ALTER TABLE TIPO_GESTION ADD CONSTRAINT FK_UUMTG FOREIGN KEY(ULTIMO_USUARIO_MODIFICADOR)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);

/*tabla principal sobre la cual será el ingreso de información
continua
    * EL campo correlativo será la llave primaria combinada
    con el campo anio, pero no sererá autoincrementable pues 
    como se detalló anteriormente, este numero se reinicia al 
    concluir cada año y es por esta causa que debe combinarse
    la restricción de llave primaria entre los 2 campos.
*/

CREATE TABLE GESTION
(
    CORRELATIVO INT(6),
    ANIO INT(4),
    ID_SECCION INT(3),
    ID_PERITO_RESPONSABLE INT(6),
    FECHA_INGRESO DATE,
    FECHA_TRANSCRIPCION DATE,
    FECHA_EGRESO DATE,
    ID_ESTADO_GESTION INT(3),
    ID_TIPO_GESTION INT(3),
    RESPONSABLE_GESTION INT(6),
    OBSERVACIONES VARCHAR(600),
    IMAGEN_ARCHIVO BLOB,
    ULTIMO_USUARIO_MODIFICADOR INT(6)
);
ALTER TABLE GESTION ADD CONSTRAINT PK_GEST PRIMARY KEY(ID_SECCION,ANIO,CORRELATIVO);
ALTER TABLE GESTION ADD CONSTRAINT FK_IDSEC FOREIGN KEY(ID_SECCION)
REFERENCES SECCION(ID_SECCION);
ALTER TABLE GESTION ADD CONSTRAINT FK_IDPRESP FOREIGN KEY(ID_PERITO_RESPONSABLE)
REFERENCES PERITO(ID_PERITO);
ALTER TABLE GESTION ADD CONSTRAINT FK_IEG FOREIGN KEY(ID_ESTADO_GESTION) REFERENCES
ESTADO_GESTION(ID_ESTADO_GESTION);
ALTER TABLE GESTION ADD CONSTRAINT FK_ITG FOREIGN KEY(ID_TIPO_GESTION) REFERENCES
TIPO_GESTION(ID_TIPO_GESTION);
ALTER TABLE GESTION ADD CONSTRAINT FK_USRRESP FOREIGN KEY(RESPONSABLE_GESTION)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);
ALTER TABLE GESTION ADD CONSTRAINT FK_USRMODIFICADOR FOREIGN KEY(ULTIMO_USUARIO_MODIFICADOR)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);


/*ALTER TABLE GESTION DROP FOREIGN KEY FK_IDSEC*/;

/*A Continuación la tabla que jugará el papel de 
bitácora en el sistema para garantizar el no repudio 
de operaciones por parte de los usuarios del sistema
*/
CREATE TABLE BITACORA_GESTION
(
    ID_TRANSACCION INT(6),
    ID_SECCION_AFECTADO INT(3),
    ANIO INT(4),
    CORRELATIVO_AFECTADO INT(6),
    ID_TIPO_MOV INT(3),
    ID_CAMPO_AFECTADO INT(3),
    FECHA_MOVIMIENTO TIMESTAMP,
    ID_USUARIO_RESP INT(6),
    VALOR_ANTERIOR VARCHAR(100),
    VALOR_NUEVO VARCHAR(100)
);
ALTER TABLE BITACORA_GESTION ADD CONSTRAINT PK_BG PRIMARY KEY(ID_TRANSACCION);
ALTER TABLE BITACORA_GESTION ADD CONSTRAINT FK_GEST FOREIGN KEY(ID_SECCION_AFECTADO,ANIO,CORRELATIVO_AFECTADO)
REFERENCES GESTION(ID_SECCION,ANIO,CORRELATIVO);
ALTER TABLE BITACORA_GESTION ADD CONSTRAINT FK_ITM FOREIGN KEY(ID_TIPO_MOV)
REFERENCES TIPO_MOVIMIENTO_GESTION(ID_TIPO_MOV);
ALTER TABLE BITACORA_GESTION ADD CONSTRAINT FK_ICA FOREIGN KEY(ID_CAMPO_AFECTADO)
REFERENCES CAMPO_AFECTADO_GESTION(ID_CAMPO);

drop table bitacora_gestion;



/*Registrar los inserts, updates y deletes que harán en respecto a los datos de usuario*/

CREATE TABLE BITACORA_USUARIO
(
    ID_TRANSACCION INT(10),
    ID_USR_AFECTADO INT(6),
    ID_TIPO_MOVIMIENTO INT(3),
    ID_CAMPO_AFECTADO INT(3),
    FECHA_MOVIMIENTO TIMESTAMP,
    ID_USR_RESPONSABLE INT(6),
    VALOR_ANTERIOR VARCHAR(100),
    VALOR_NUEVO VARCHAR(100)
);
ALTER TABLE BITACORA_USUARIO ADD CONSTRAINT PK_BIUSR PRIMARY KEY (ID_TRANSACCION);
ALTER TABLE BITACORA_USUARIO MODIFY COLUMN ID_TRANSACCION INT(10) AUTO_INCREMENT;
ALTER TABLE BITACORA_USUARIO ADD CONSTRAINT FK_IDUSRAFEC FOREIGN KEY(ID_USR_AFECTADO)
REFERENCES USUARIO_SISTEMA(ID_USUARIO);
ALTER TABLE BITACORA_USUARIO ADD CONSTRAINT FK_IDCAAFEC FOREIGN KEY (ID_CAMPO_AFECTADO)
REFERENCES CAMPO_AFECTADO_USUARIO(ID_CAMPO);
ALTER TABLE BITACORA_USUARIO ADD CONSTRAINT FK_ITPMU FOREIGN KEY (ID_TIPO_MOVIMIENTO)
REFERENCES TIPO_MOVIMIENTO_USUARIO(ID_TIPO_MOVIMIENTO);





/*Registrar los inserts, updates y deletes que harán en respecto a los datos de un perito*/

CREATE TABLE BITACORA_PERITO
(
    ID_TRANSACCION INT(10),
    ID_PERITO_AFECTADO INT(6),
    ID_TIPO_MOVIMIENTO INT(3),
    ID_CAMPO_AFECTADO INT(3),
    FECHA_MOVIMIENTO TIMESTAMP,
    ID_USR_RESPONSABLE INT(6),
    VALOR_ANTERIOR VARCHAR(100),
    VALOR_NUEVO VARCHAR(100)
);
ALTER TABLE BITACORA_PERITO ADD CONSTRAINT PK_BIPER PRIMARY KEY (ID_TRANSACCION);
ALTER TABLE BITACORA_PERITO MODIFY COLUMN ID_TRANSACCION INT(10) AUTO_INCREMENT;
ALTER TABLE BITACORA_PERITO ADD CONSTRAINT FK_PERAFEC FOREIGN KEY(ID_PERITO_AFECTADO)
REFERENCES PERITO(ID_PERITO);
ALTER TABLE BITACORA_PERITO ADD CONSTRAINT FK_IDCPERAFEC FOREIGN KEY (ID_CAMPO_AFECTADO)
REFERENCES CAMPO_AFECTADO_PERITO(ID_CAMPO);
ALTER TABLE BITACORA_PERITO ADD CONSTRAINT FK_ITMPER FOREIGN KEY (ID_TIPO_MOVIMIENTO)
REFERENCES TIPO_MOVIMIENTO_PERITO(ID_TIPO_MOVIMIENTO);




/*Registrar los inserts, updates y deletes que harán en respecto a los datos de la seccion*/

CREATE TABLE BITACORA_SECCION
(
    ID_TRANSACCION INT(10),
    ID_SEC_AFECTADO INT(6),
    ID_TIPO_MOVIMIENTO INT(3),
    ID_CAMPO_AFECTADO INT(3),
    FECHA_MOVIMIENTO TIMESTAMP,
    ID_USR_RESPONSABLE INT(6),
    VALOR_ANTERIOR VARCHAR(100),
    VALOR_NUEVO VARCHAR(100)
);
ALTER TABLE BITACORA_SECCION ADD CONSTRAINT PK_BIUSEC PRIMARY KEY (ID_TRANSACCION);
ALTER TABLE BITACORA_SECCION MODIFY COLUMN ID_TRANSACCION INT(10) AUTO_INCREMENT;
ALTER TABLE BITACORA_SECCION ADD CONSTRAINT FK_IDUSECAFEC FOREIGN KEY(ID_SEC_AFECTADO)
REFERENCES SECCION(ID_SECCION);
ALTER TABLE BITACORA_SECCION ADD CONSTRAINT FK_IDCSECAFEC FOREIGN KEY (ID_CAMPO_AFECTADO)
REFERENCES CAMPO_AFECTADO_SECCION(ID_CAMPO);
ALTER TABLE BITACORA_SECCION ADD CONSTRAINT FK_ITPMSEC FOREIGN KEY (ID_TIPO_MOVIMIENTO)
REFERENCES TIPO_MOVIMIENTO_SECCION(ID_TIPO_MOVIMIENTO);



/*tabla para registar las incersiones, actualizaciones y baja de tipos de secciones en TFM*/

CREATE TABLE BITACORA_TIPO_GESTION
(
    ID_TRANSACCION INT(10),
    ID_TIPO_GESTION_AFECTADO INT(6),
    ID_TIPO_MOVIMIENTO INT(3),
    ID_CAMPO_AFECTADO INT(3),
    FECHA_MOVIMIENTO TIMESTAMP,
    ID_USR_RESPONSABLE INT(6),
    VALOR_ANTERIOR VARCHAR(100),
    VALOR_NUEVO VARCHAR(100)
);
ALTER TABLE BITACORA_TIPO_GESTION ADD CONSTRAINT PK_BTGES PRIMARY KEY (ID_TRANSACCION);
ALTER TABLE BITACORA_TIPO_GESTION MODIFY COLUMN ID_TRANSACCION INT(10) AUTO_INCREMENT;
ALTER TABLE BITACORA_TIPO_GESTION ADD CONSTRAINT FK_IDGAFEC FOREIGN KEY(ID_TIPO_GESTION_AFECTADO)
REFERENCES TIPO_GESTION(ID_TIPO_GESTION);
ALTER TABLE BITACORA_TIPO_GESTION ADD CONSTRAINT FK_IDCATG FOREIGN KEY (ID_CAMPO_AFECTADO)
REFERENCES CAMPO_AFECTADO_TIPO_GESTION(ID_CAMPO);
ALTER TABLE BITACORA_TIPO_GESTION ADD CONSTRAINT FK_ITPBTG FOREIGN KEY (ID_TIPO_MOVIMIENTO)
REFERENCES TIPO_MOVIMIENTO_TIPO_GESTION(ID_TIPO_MOVIMIENTO);





/****************************************************************************************************************/
                                        /*INSERCIÓN DE DATOS INICIALES*/
/****************************************************************************************************************/


/* CAMPO_AFECTADO_GESTION: IRÁN EL NOMBRE DE LOS CAMPOS CORRESPONDIENTES A LA TABLA GESTIÓN,
A FIN DE SABER CUANDO SE DISPAREN LOS TRIGGERS SOBRE ESA TABLA, QUE CAMPOS FUERON AFECTADOS POR 
ACCIONES DE UPDATE O DELETE (DELETE EN ESTE CASO SERÁ UN ESTADO DE BAJA, A FIN DE NO MOSTRAR
YA ESOS DATOS AL USUARIO PERO NO BORRARLOS DEL SISTEMA)*/
USE TFM;
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('CORRELATIVO');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('ANIO');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('ID_SECCION');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('ID_PERITO_RESPONSABLE');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('FECHA_INGRESO');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('FECHA_TRANSCRIPCION');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('FECHA_EGRESO');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('ID_ESTADO_GESTION');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('ID_TIPO_GESTION');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('RESPONSABLE_GESTION');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('OBSERVACIONES');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('IMAGEN_ARCHIVO');
INSERT INTO CAMPO_AFECTADO_GESTION(NOMBRE) VALUES('ULTIMO_USUARIO_RESPONSABLE');

/*TIPO_MOVIMIENTO_USUARIO: SE REGISTRÁ LOS MOVIMIENTOS QUE HAGA EL USUARIO FINAL SOBRE LA TABLA
USUARIO, ESTOS PUEDEN SER INSERCIÓN, ACTUALIZACIÓN O BORRADO=BAJA DEL SISTEMA AL HABLAR DE BAJA,
ME REFIERO A QUE LOS DATOS YA NO ESTARÁN VISIBLES PARA LOS USUARIOS FINALES, POR LO TANTO,
NO SERÁN ELIMINADOS DEL SISTEMA PARA PRESERVAR Y GARANTIZAR LA INTEGRIDAD DE LA INFORMACIÓN DESDE
ESTA PERSPECTIVA */
INSERT INTO TIPO_MOVIMIENTO_USUARIO(DESCRIPCION) VALUES('INSERCIÓN');
INSERT INTO TIPO_MOVIMIENTO_USUARIO(DESCRIPCION) VALUES('ACTUALIZACIÓN');
INSERT INTO TIPO_MOVIMIENTO_USUARIO(DESCRIPCION) VALUES('BAJA');

/*TIPO_MOVIMIENTO_PERITO: SE REGISTRÁ LOS MOVIMIENTOS QUE HAGA EL USUARIO FINAL SOBRE LA TABLA
PERITO, ESTOS PUEDEN SER INSERCIÓN, ACTUALIZACIÓN O BORRADO=BAJA DEL SISTEMA AL HABLAR DE BAJA,
ME REFIERO A QUE LOS DATOS YA NO ESTARÁN VISIBLES PARA LOS USUARIOS FINALES, POR LO TANTO,
NO SERÁN ELIMINADOS DEL SISTEMA PARA PRESERVAR Y GARANTIZAR LA INTEGRIDAD DE LA INFORMACIÓN DESDE
ESTA PERSPECTIVA */
INSERT INTO TIPO_MOVIMIENTO_PERITO(DESCRIPCION) VALUES('INSERCIÓN');
INSERT INTO TIPO_MOVIMIENTO_PERITO(DESCRIPCION) VALUES('ACTUALIZACIÓN');
INSERT INTO TIPO_MOVIMIENTO_PERITO(DESCRIPCION) VALUES('BAJA');


/*TIPO_MOVIMIENTO_PERITO: SE REGISTRÁ LOS MOVIMIENTOS QUE HAGA EL USUARIO FINAL SOBRE LA TABLA
SECCION, ESTOS PUEDEN SER INSERCIÓN, ACTUALIZACIÓN O BORRADO=BAJA DEL SISTEMA AL HABLAR DE BAJA,
ME REFIERO A QUE LOS DATOS YA NO ESTARÁN VISIBLES PARA LOS USUARIOS FINALES, POR LO TANTO,
NO SERÁN ELIMINADOS DEL SISTEMA PARA PRESERVAR Y GARANTIZAR LA INTEGRIDAD DE LA INFORMACIÓN DESDE
ESTA PERSPECTIVA */
INSERT INTO TIPO_MOVIMIENTO_SECCION(DESCRIPCION) VALUES('INSERCIÓN');
INSERT INTO TIPO_MOVIMIENTO_SECCION(DESCRIPCION) VALUES('ACTUALIZACIÓN');
INSERT INTO TIPO_MOVIMIENTO_SECCION(DESCRIPCION) VALUES('BAJA');



/*TIPO_MOVIMIENTO_GESTION: SE REGISTRÁ LOS MOVIMIENTOS QUE HAGA EL USUARIO FINAL SOBRE LA TABLA
GESTION, ESTOS PUEDEN SER INSERCIÓN, ACTUALIZACIÓN O BORRADO=BAJA DEL SISTEMA AL HABLAR DE BAJA,
ME REFIERO A QUE LOS DATOS YA NO ESTARÁN VISIBLES PARA LOS USUARIOS FINALES, POR LO TANTO,
NO SERÁN ELIMINADOS DEL SISTEMA PARA PRESERVAR Y GARANTIZAR LA INTEGRIDAD DE LA INFORMACIÓN DESDE
ESTA PERSPECTIVA */
INSERT INTO TIPO_MOVIMIENTO_GESTION(DESCRIPCION) VALUES('INSERCIÓN');
INSERT INTO TIPO_MOVIMIENTO_GESTION(DESCRIPCION) VALUES('ACTUALIZACIÓN');
INSERT INTO TIPO_MOVIMIENTO_GESTION(DESCRIPCION) VALUES('BAJA');



/*TIPO_MOVIMIENTO_TIPO_GESTION: SE REGISTRÁ LOS MOVIMIENTOS QUE HAGA EL USUARIO FINAL SOBRE LA TABLA
USUARIO, ESTOS PUEDEN SER INSERCIÓN, ACTUALIZACIÓN O BORRADO=BAJA DEL SISTEMA AL HABLAR DE BAJA,
ME REFIERO A QUE LOS DATOS YA NO ESTARÁN VISIBLES PARA LOS USUARIOS FINALES, POR LO TANTO,
NO SERÁN ELIMINADOS DEL SISTEMA PARA PRESERVAR Y GARANTIZAR LA INTEGRIDAD DE LA INFORMACIÓN DESDE
ESTA PERSPECTIVA */
INSERT INTO TIPO_MOVIMIENTO_TIPO_GESTION(DESCRIPCION) VALUES('INSERCIÓN');
INSERT INTO TIPO_MOVIMIENTO_TIPO_GESTION(DESCRIPCION) VALUES('ACTUALIZACIÓN');
INSERT INTO TIPO_MOVIMIENTO_TIPO_GESTION(DESCRIPCION) VALUES('BAJA');




/*ESTADO_TIPO_GESTION: UN TIPO DE GESTION PUEDE ESTAR ACTIVO , PERO SE DEJARÁ LA OPCIÓN DE DARLE
DE "BAJA" DEL SISTEMA*/
INSERT INTO ESTADO_TIPO_GESTION(NOMBRE) VALUES('ACTIVO');
INSERT INTO ESTADO_TIPO_GESTION(NOMBRE) VALUES('BAJA');


/*ESTADO_PERITO: UN PERITO PUEDE ESTAR ACTIVO E INACTIVO, PERO SE DEJARÁ LA OPCIÓN DE DARLE
DE "BAJA" DEL SISTEMA*/
INSERT INTO ESTADO_PERITO(NOMBRE) VALUES('ACTIVO');
INSERT INTO ESTADO_PERITO(NOMBRE) VALUES('INACTIVO');
INSERT INTO ESTADO_PERITO(NOMBRE) VALUES('BAJA');

/*CAMPO_AFECTADO_PERITO: CONTIENE EL NOMBRE DE LOS CAMPOS REFERENTES A LA TABLA PERITO
A FIN DE IDENTIFICAR CUANDO ALGÚN ATRIBUTO SEA ACTUALIZADO Y ALMACENAR EL VALOR ANTIGUO Y NUEVO*/
INSERT INTO CAMPO_AFECTADO_PERITO(DESCRIPCION) VALUES('PERITO');
INSERT INTO CAMPO_AFECTADO_PERITO(DESCRIPCION) VALUES('NOMBRES');
INSERT INTO CAMPO_AFECTADO_PERITO(DESCRIPCION) VALUES('APELLIDOS');
INSERT INTO CAMPO_AFECTADO_PERITO(DESCRIPCION) VALUES('ULTIMA_FECHA_MODIFICACION');
INSERT INTO CAMPO_AFECTADO_PERITO(DESCRIPCION) VALUES('ID_ESTADO_PERITO');
INSERT INTO CAMPO_AFECTADO_PERITO(DESCRIPCION) VALUES('ULTIMO_USUARIO_MODIFICADOR');


/*CAMPO_AFECTADO_SECCION: CONTIENE EL NOMBRE DE LOS CAMPOS REFERENTES A LA TABLA SECCION
A FIN DE IDENTIFICAR CUANDO ALGÚN ATRIBUTO SEA ACTUALIZADO Y ALMACENAR EL VALOR ANTIGUO Y NUEVO*/
INSERT INTO CAMPO_AFECTADO_SECCION(DESCRIPCION) VALUES('ID_SECCION');
INSERT INTO CAMPO_AFECTADO_SECCION(DESCRIPCION) VALUES('NOMBRE');
INSERT INTO CAMPO_AFECTADO_SECCION(DESCRIPCION) VALUES('IDENTIFICADOR');
INSERT INTO CAMPO_AFECTADO_SECCION(DESCRIPCION) VALUES('ULTIMO_USUARIO_MODIFICADOR');
INSERT INTO CAMPO_AFECTADO_SECCION(DESCRIPCION) VALUES('ID_ESTADO_SECCION');


/*CAMPO_AFECTADO_TIPO_GESTION: CONTIENE EL NOMBRE DE LOS CAMPOS REFERENTES A LA TABLA TIPO_GESTION
A FIN DE IDENTIFICAR CUANDO ALGÚN ATRIBUTO SEA ACTUALIZADO Y ALMACENAR EL VALOR ANTIGUO Y NUEVO*/
INSERT INTO CAMPO_AFECTADO_TIPO_GESTION(DESCRIPCION) VALUES('ID_TIPO_GESTION');
INSERT INTO CAMPO_AFECTADO_TIPO_GESTION(DESCRIPCION) VALUES('NOMBRE');
INSERT INTO CAMPO_AFECTADO_TIPO_GESTION(DESCRIPCION) VALUES('ID_CLASE_GESTION');
INSERT INTO CAMPO_AFECTADO_TIPO_GESTION(DESCRIPCION) VALUES('ID_ESTADO_TIPO_GESTION');
INSERT INTO CAMPO_AFECTADO_TIPO_GESTION(DESCRIPCION) VALUES('ULTIMO_USUARIO_MODIFICADOR');



/*ESTADO_GESTION: La gestión tendrá los siguientes estados:
1.-Recepción: La gestión fue creada.
2.-Transcripcion: La gestión se encuentra en proceso de digitalización de la información.
3.-Cotejo: La gestión fue asignada al perito y se encuentra en el análisis correspondiente.
4.-Firma: El expediente se encuentra impreso y está pendiente de firma por el perito a cargo
5.-Evacuación: Expediente fue entregado a la sección de seguimiento pericial (concluye el trabajo
por parte de Tanatología Forense Metropolitana);
*/

INSERT INTO ESTADO_GESTION(NOMBRE) VALUES('RECEPCION');
INSERT INTO ESTADO_GESTION(NOMBRE) VALUES('TRANSCRIPCION');
INSERT INTO ESTADO_GESTION(NOMBRE) VALUES('COTEJO');
INSERT INTO ESTADO_GESTION(NOMBRE) VALUES('FIRMA');
INSERT INTO ESTADO_GESTION(NOMBRE) VALUES('EVACUACION');


/*TIPO_MOVIMIENTO_GESTION: DEFINE LAS ACCIONES QUE UN USUARIO REALIZA SOBRE LA TABLA TIPO_MOVIMIENTO_GESTION
A REGISTAR EN LA BITÁCORA DE USUARIO, ESTAS SON: INSERCION, ACTUALIZACION O BAJA*/

INSERT INTO TIPO_MOVIMIENTO_GESTION(DESCRIPCION) VALUES('INSERCION');
INSERT INTO TIPO_MOVIMIENTO_GESTION(DESCRIPCION) VALUES('ACTUALIZACION');
INSERT INTO TIPO_MOVIMIENTO_GESTION(DESCRIPCION) VALUES('BAJA');

/*CAMPO_AFECTADO_USUARIO: CONTIENE EL NOMBRE DE LOS CAMPOS REFERENTES A LA TABLA USUARIO_SISTEMA
A FIN DE IDENTIFICAR CUANDO ALGÚN ATRIBUTO SEA ACTUALIZADO Y ALMACENAR EL VALOR ANTIGUO Y NUEVO*/
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('ID_USUARIO');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('NOMBRES');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('APELLIDOS');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('ID_ESTADO_USR');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('ID_ROL');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('ACCESO');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('ULTIMO_LOGIN');
INSERT INTO CAMPO_AFECTADO_USUARIO(DESCRIPCION) VALUES('ULTIMO_USUARIO_MODIFICADOR');




/*ESTADO_SECCION: LA SECCION PODRÁ ESTAR:
1.- ACTIVO
2.-BAJA(ELIMINADO= NO VISIBLE PARA EL USUARIO FINAL, PERO EXISTENTE AÚN EN LA BASE DE DATOS)*/
INSERT INTO ESTADO_SECCION(NOMBRE)VALUES('ACTIVO');
INSERT INTO ESTADO_SECCION(NOMBRE)VALUES('BAJA');


/*ESTADO_USUARIO: EL USUARIO PODRÁ ESTAR:
1.- ACTIVO
2.-INACTIVO
3.-BAJA(ELIMINADO= NO VISIBLE PARA EL USUARIO FINAL, PERO EXISTENTE AÚN EN LA BASE DE DATOS)*/
INSERT INTO ESTADO_USUARIO(NOMBRE)VALUES('ACTIVO');
INSERT INTO ESTADO_USUARIO(NOMBRE)VALUES('INACTIVO');
INSERT INTO ESTADO_USUARIO(NOMBRE)VALUES('BAJA');




/*ROL USUARIO:EXISTIRÀN LOS SIGUIENTES:

1.- ADMIN. DEL SISTEMA 
2.-JEFATURA
3.-Auxiliar Administrativo*/

insert into rol_usuario(DESCRIPCION) values('ADMINISTRADOR');
insert into rol_usuario(DESCRIPCION) values('JEFATURA');
insert into rol_usuario(DESCRIPCION) values('AUXILIAR_ADMINISTRATIVO');


/*SECCION: Se refiere a las secciones existentes en la Unidad de Tanatologìa Foresnse Metropolitana,
actualmente son las siguientes:
o	PCEN: (Patología Central), se refiere a la Sección de Medicina Forense Tanatológica.
o	OD: (Odontología), hace alusión a la Sección de Necro-Odontología.
o	HISTOCEN: (Histopatología Central), referente a la Sección de Histopatología.
o	ANTRO (Antropología), se refiere a la Sección de Antropología Forense.
o	ARQU(Arqueología), referente a la Sección de Arqueología Forense.
*/

INSERT INTO SECCION (NOMBRE,IDENTIFICADOR) VALUES('TANATOLOGÍA FORENSE METROPOLITANA','PCEN');
INSERT INTO SECCION (NOMBRE,IDENTIFICADOR) VALUES('ODONTOLOGÍA FORENSE','OD');
INSERT INTO SECCION (NOMBRE,IDENTIFICADOR) VALUES('HISTOPALOGÍA CENTRAL','HISTOCEN');
INSERT INTO SECCION (NOMBRE,IDENTIFICADOR) VALUES('ANTROPOLOGÍA FORENSE','ANTRO');
INSERT INTO SECCION (NOMBRE,IDENTIFICADOR) VALUES('ARQUEOLOGÍA FORENSE','ARQU');


/*CLASE DE GESTIÓN: DESCRIBE SI EL TIPO DE GESTIÓN ES:
o   PERITAJE
o   OFICIO*/

INSERT INTO CLASE_GESTION (NOMBRE) VALUES('PERITAJE');
INSERT INTO CLASE_GESTION (NOMBRE) VALUES('OFICIO');



/*TIPO_GESTION: 
o   NECROPSIA_MÉDICO_LEGAL
o	Ampliación.
o	Rectificación.
o	Reiteración de orden.
o	Búsqueda de personas desaparecidas.
o	Correlaciones de expedientes clínicos y necropsias.
o	Citaciones a debates (presenciales o videoconferencias).
o	Respuesta Administrativa (por parte de Jefatura de Tanatología Forense).
o   
*/

INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('NECROPSIA',1);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('AMPLIACION',2);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('RECTIFICACION',2);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('REITERACION',2);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('BÚSQUEDA',2);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('EXP.CLINICO',1);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('CITACION_DEBATE',2);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('RESP.ADMINISTRATIVA',2);
INSERT INTO TIPO_GESTION(NOMBRE,ID_CLASE_GESTION) VALUES('SG(ASISTENCIAS_JUDICIALES)',2);



/***********************************************************************************************************/
                                        /*LÓGICA DEL NEGOCIO*/
/***********************************************************************************************************/
/*CRUD USUASARIO : (CREACION, ACTUALIZACION Y BAJA DE USUARIOS EN EL SISTEMA*/
/***********************************************************************************************************/
                                        /*VISTAS CRUD USUARIO*/
/***********************************************************************************************************/

/*LA VISTA  NOS PERMITIRÀ MOSTRAR ÚNICAMENTE LOS DATOS 
DE LA TABLA USUARIO PARA NO USAR DE FORMA DIRECTA LA TABLA Y NO VULNERAR ESTA*/
DROP VIEW IF EXISTS VISTA_CRUD_USUARIO;
CREATE VIEW VISTA_CRUD_USUARIO(NIP,NOMBRES,APELLIDOS,ESTADO_USUARIO,ROL,ACCESO,ULTIMO_LOGIN)
AS
(SELECT US.ID_USUARIO,US.NOMBRES,US.APELLIDOS,EU.NOMBRE,R.DESCRIPCION,US.ACCESO,US.ULTIMO_LOGIN 
FROM USUARIO_SISTEMA US
INNER JOIN ESTADO_USUARIO EU
ON US.ID_ESTADO_USR=EU.ID_ESTADO_USR
INNER JOIN ROL_USUARIO R
ON US.ID_ROL=R.ID_ROL WHERE EU.NOMBRE<>'BAJA');


/*vista para mostrar  el rol de usuarios actuales en el sistema*/
DROP VIEW IF EXISTS VISTA_DATOS;
DELIMITER //
CREATE VIEW VISTA_DATOS(DESCRIPCION) AS (SELECT DESCRIPCION FROM ROL_USUARIO);
// DELIMITER;

/***********************************************************************************************************/
                                        /*FUNCIONES CRUD USUARIO*/
/***********************************************************************************************************/


/*FUNCION PARA SABER  el rol de un usuario en específico*/
DROP FUNCTION IF EXISTS FUNCT_NOMBRE_ROL_USUARIO;
DELIMITER //
CREATE FUNCTION FUNCT_NOMBRE_ROL_USUARIO(NIP_URS INT) RETURNS VARCHAR(100)
BEGIN
    DECLARE DESCRIPCION_ROL VARCHAR(100);
    /*Valido que el usuario exista, y esté activo*/
    SET DESCRIPCION_ROL=(SELECT RU.DESCRIPCION FROM ROL_USUARIO RU
    INNER JOIN USUARIO_SISTEMA US ON 
    RU.ID_ROL = US.ID_ROL
    WHERE US.ID_USUARIO=NIP_URS AND  US.ID_ESTADO_USR=4);

    IF(DESCRIPCION_ROL!='') THEN
        RETURN DESCRIPCION_ROL;
    ELSE
        SIGNAL SQLSTATE '20005' SET MESSAGE_TEXT = "EL ROL O USUARIO 
        NO EXISTEN EN EL SISTEMA";
    END IF;
END// DELIMITER;


/*funcion para validar que existe el usuario que pretende modificar el estado de otro,
,si existe, devuelve 1 y sino 0, además que tenga privilegios de administrador*/
DROP FUNCTION  IF EXISTS FUNCT_EXISTE_USR_ADMIN;
DELIMITER //
CREATE FUNCTION FUNCT_EXISTE_USR_ADMIN(NIP_RESP INT) RETURNS INT
    BEGIN 
        /*Variable en la cual vamos a devolver el resultado de un count
        que realizaré para validar si un usuario existe en la bd y está activo*/
        DECLARE CONTAR_RESULTADO INT;
        /*Variable para capturar el rol de un usuario*/
        DECLARE ROL_USR_RESP VARCHAR(100);
        /*verifico si el usuario que quiere modificar el estado de otro,
        existe en la bd*/
        SET CONTAR_RESULTADO=(SELECT COUNT(*) FROM USUARIO_SISTEMA WHERE ID_USUARIO=NIP_RESP AND ID_ESTADO_USR<>6 AND ID_ESTADO_USR<>5);
        /*Valido que el usuario tenga rol de admin*/
        SET ROL_USR_RESP=(SELECT FUNCT_NOMBRE_ROL_USUARIO(NIP_RESP));
        /*realizo una condicional para validar que el usuario exista en la bd y tenga
        rol de usuario para hacer el proceso*/
        IF(CONTAR_RESULTADO=1 AND ROL_USR_RESP="ADMINISTRADOR") THEN
            RETURN 1;
        ELSE
            RETURN 0;
        END IF;  
END// DELIMITER;



/*función para determinar si existe ya un usuario con el nip en el sistema*/
DROP FUNCTION IF EXISTS FUNCT_EXISTE_USUARIO_SISTEMA;
DELIMITER //
CREATE FUNCTION FUNCT_EXISTE_USUARIO_SISTEMA(NIP_NUEVO INT) RETURNS INT
BEGIN
    SET @VERIFICAR_ID_USR=(SELECT COUNT(*) FROM USUARIO_SISTEMA WHERE ID_USUARIO=NIP_NUEVO);

    IF(@VERIFICAR_ID_USR>0) THEN
        RETURN @VERIFICAR_ID_USR;
    ELSE
        RETURN @VERIFICAR_ID_USR;
    END IF;
END// DELIMITER;



/*FUNCION PARA DEVOLVER EL ID DEL TIPO DE "ESTADO BAJA"*/
DROP FUNCTION IF EXISTS FUNCT_DEVOLVER_ESTADO_USR_BAJA;
DELIMITER //
CREATE FUNCTION FUNCT_DEVOLVER_ESTADO_USR_BAJA() RETURNS INT(03)
BEGIN
    DECLARE ID_ESTADO_BAJA INT;
    SET ID_ESTADO_BAJA=(SELECT ID_ESTADO_USR FROM ESTADO_USUARIO WHERE NOMBRE="BAJA");

    IF(ID_ESTADO_BAJA!='') THEN
        RETURN ID_ESTADO_BAJA;
    ELSE
        SIGNAL SQLSTATE '20014' SET MESSAGE_TEXT = "ERROR AL BUSCAR EL ESTADO DE USUARIO, CONTACTE AL DBA";
    END IF;
END// DELIMITER;




/***********************************************************************************************************/
                                        /*PROCEDIMIENTOS ALMACENADOS CRUD USUARIO*/
/***********************************************************************************************************/
/*Procedimiento almacenado para la creación de Un usuario del sistema,*/
DROP PROCEDURE IF EXISTS PA_CREAR_USUARIO_SISTEMA;
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_CREAR_USUARIO_SISTEMA`(IN NIP_NUEVO INT, IN NOMBRES_USR_NUEVO VARCHAR(200),IN APELLIDOS_USR_NUEVO VARCHAR(100),IN NOMBRE_ROL_USUARIO_NUEVO VARCHAR(100),IN CONTRASENIA_USR_NUEVO VARCHAR(100),IN NIP_ULT_USR_MOD INT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20001' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de creación de usuario";
    END;
    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            /*VERIFICAMOS SI EL USUARIO EXISTE EN EL SISTEMA*/
            SET @EXISTE_USUARIO = (SELECT FUNCT_EXISTE_USUARIO_SISTEMA(NIP_NUEVO));
            IF(@EXISTE_USUARIO=0) THEN
                /*EVALUAMOS QUE EL ROL EXISTE EN LA BD Y EXTRAEMOS EL ID DE ESTE*/
                SET @NROL_USUARIO=(SELECT ID_ROL FROM ROL_USUARIO 
                WHERE DESCRIPCION=NOMBRE_ROL_USUARIO_NUEVO LIMIT 1);
                /*que el rol sea de administrador*/ 
                IF(@NROL_USUARIO IN(4)) THEN
                    INSERT INTO USUARIO_SISTEMA
                    (ID_USUARIO,NOMBRES,APELLIDOS,ID_ESTADO_USR,ID_ROL,ACCESO,ULTIMO_LOGIN,ULTIMO_USUARIO_MODIFICADOR)
                    VALUES
                    (NIP_NUEVO,NOMBRES_USR_NUEVO,APELLIDOS_USR_NUEVO,4,@NROL_USUARIO,CONTRASENIA_USR_NUEVO,NOW(),NIP_ULT_USR_MOD);
                ELSE
                SIGNAL SQLSTATE '20002' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
                END IF;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20003' SET MESSAGE_TEXT = 'El usuario ya existe, sino lo observa en la tabla, comuníquese con el desarrollador';
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20004' SET MESSAGE_TEXT='¡Usted no tiene privilegios de Administrador!';
            ROLLBACK;
        END IF;
END;

/*call PA_CREAR_USUARIO_SISTEMA(1759,'IRON','MAIDEN','ADMINISTRADOR','ROCK',1751);*/

/*procedimiento almacenado para la actualización de datos de un usuario*/
DROP PROCEDURE IF EXISTS PA_ACTUALIZAR_USUARIO_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZAR_USUARIO_SISTEMA`(IN NIP_FIJO INT, IN NOMBRES_USR_EDITAR VARCHAR(100),
IN APELLIDOS_USR_EDITAR VARCHAR(100),IN NOMBRE_ROL_USUARIO_EDITAR VARCHAR(100),IN CONTRASENIA_USR_EDITAR VARCHAR(100),IN NIP_ULT_USR_MOD INT)
BEGIN
    /*variables para capturar los datos recuperados de la bd del usuario
    a través de un cursor*/
    DECLARE C_NIP INT(10);
    DECLARE C_NOMBRES VARCHAR(200);
    DECLARE C_APELLIDOS VARCHAR(200);
    DECLARE C_ID_ROL_USUARIO INT(3);
    DECLARE C_ACCESO VARCHAR(200);
    DECLARE C_NIP_ULT_USR_MODIFICADOR INT(10);
    /*variable para cerrar el loop*/
    DECLARE FIN_LOOP INTEGER DEFAULT 0;
    /*creo un cursor para recuperar los datos del usuario a actualizar (datos)*/
    DECLARE CURSOR_SELECCION_USUARIO CURSOR FOR
    SELECT ID_USUARIO,NOMBRES,APELLIDOS,ID_ROL,ACCESO,ULTIMO_USUARIO_MODIFICADOR
    FROM USUARIO_SISTEMA WHERE ID_USUARIO=NIP_FIJO;

    /*VARIABLE PARA CONTROLAR EL FINAL DE RECORRIDO DEL CURSOR*/
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIN_LOOP=1; 
    /*excepción para hacer rolback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, SINO
    EN alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20006' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de usuario";
    END;

    START TRANSACTION;

        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            /*EVALUAMOS QUE EL ROL EXISTE EN LA BD*/
            SET @NROL_USUARIO=(SELECT ID_ROL FROM ROL_USUARIO 
            WHERE DESCRIPCION=NOMBRE_ROL_USUARIO_EDITAR LIMIT 1);
            /*SI EL ID DE ROL DE USUARIO SE ENCUENTRA DENTRO DE LOS PERMITIDOS (administrador)*/ 
            IF(@NROL_USUARIO IN(4)) THEN
                /*abrimos el cursor*/
                OPEN CURSOR_SELECCION_USUARIO;
                    CICLO: LOOP
                    FETCH CURSOR_SELECCION_USUARIO INTO C_NIP,C_NOMBRES, C_APELLIDOS,
                    C_ID_ROL_USUARIO,C_ACCESO, C_NIP_ULT_USR_MODIFICADOR;
                        /*comprobamos si llegamos al final de los registros obtenidos del cursor*/
                        IF FIN_LOOP = 1 THEN
                            LEAVE CICLO;
                        END IF;
                        /*HARÉ VALIDACIÓN DE CAMPO POR CAMPO PARA IDENTIFICAR SI VARIA EL VALOR ANTIGUO
                        DE CADA UNO CON EL NUEVO ENVIADO POR EL USUARIO DESDE LA VISTA*/
                        /*SI SE ACTUALIZA EL NOMBRE DEL USUARIO*/
                        IF(NOMBRES_USR_EDITAR<>C_NOMBRES) THEN
                            UPDATE USUARIO_SISTEMA SET NOMBRES=NOMBRES_USR_EDITAR WHERE ID_USUARIO=NIP_FIJO;
                        END IF;
                        /*SI LOS APELLIDOS O APELLIDO SON O ES ACTUALIZADO*/
                        IF(APELLIDOS_USR_EDITAR<>C_APELLIDOS) THEN
                            UPDATE USUARIO_SISTEMA SET APELLIDOS=APELLIDOS_USR_EDITAR WHERE ID_USUARIO=NIP_FIJO;
                        END IF;
                        /*SI EL ROL ES ALTERADO*/
                        IF(C_ID_ROL_USUARIO<>@NROL_USUARIO) THEN
                            UPDATE USUARIO_SISTEMA SET  ID_ROL=@NROL_USUARIO WHERE ID_USUARIO=NIP_FIJO;
                        END IF;
                        /*SI LA CONTRASEÑA ES CAMBIADA*/
                        IF(C_ACCESO<>CONTRASENIA_USR_EDITAR) THEN
                            UPDATE USUARIO_SISTEMA SET ACCESO=CONTRASENIA_USR_EDITAR WHERE ID_USUARIO=NIP_FIJO;
                        END IF;
                        /*DEBEMOS REGISTAR QUE USUARIO CON PRIVILEGIOS DE ADMIN 
                        FUE EL ÚLITMO EN EDITAR A OTRO USUARIO*/
                        IF(C_NIP_ULT_USR_MODIFICADOR<>NIP_ULT_USR_MOD) THEN
                            UPDATE USUARIO_SISTEMA SET ULTIMO_USUARIO_MODIFICADOR=C_NIP_ULT_USR_MODIFICADOR
                            WHERE ID_USUARIO=NIP_FIJO;
                        END IF;         
                    END LOOP CICLO;
                CLOSE CURSOR_SELECCION_USUARIO;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20007' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
            ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20008' SET MESSAGE_TEXT = '¡USTED NO TIENE PRIVILEGIOS PARA RELIZAR ESTAS ACCIONES!';
        END IF;    
END// DELIMITER;


/*CALL PA_ACTUALIZAR_USUARIO_SISTEMA(1754,'PEDRO','APOSTOL','JEFATURA','DOS MIL VEINTIDÓS',1751);*/



/*Procedimiento Almacenado para la actualización de estado de un usuario*/
/*Recibe como parámetros el nip del usuario a modificar el estado, el estado nuevo (activo, inactivo)
y el NIP del usuario logueado que hace la modificación del estado*/
DROP PROCEDURE  IF EXISTS PA_ACTUALIZACION_ESTADO_USR;
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZACION_ESTADO_USR`(IN NIP_FIJO INT, IN ESTADO_USUARIO INT,IN NIP_USR_RESP INT)
BEGIN
    /*excepción para hacer rolLback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, sino
    en alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20009' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de estado del usuario";
    END;

    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_USR_RESP));
        IF(@PRIVILEGIOS=1) THEN
            UPDATE USUARIO_SISTEMA SET ID_ESTADO_USR=ESTADO_USUARIO WHERE ID_USUARIO=NIP_FIJO;
            UPDATE USUARIO_SISTEMA SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_USUARIO=NIP_FIJO;
        ELSE
            SIGNAL SQLSTATE '20010' SET MESSAGE_TEXT = "¡Usted no tiene privilegios de Administrador!";
            ROLLBACK;
        END IF;
    COMMIT;
    END// DELIMITER;

   /* CALL PA_ACTUALIZACION_ESTADO_USR(1754,5,1751);*/



/*PROCEDIMIENTO ALMACENAOD PARA DAR DE BAJA A UN USUARIO DEL SISTEMA*/
DROP PROCEDURE  IF EXISTS PA_BAJA_USR_SISTEMA;
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_BAJA_USR_SISTEMA`(IN NIP_FIJO INT,IN NIP_USR_RESP INT)
BEGIN
    /*Variable para determinar si el usuario que quiere hacer el UPDATE 
    existe en la bd, y tiene rol de administrador*/
    DECLARE VALIDAR_ROL INT;
    /*Variable para recuperar el id del estado "baja"*/
    DECLARE ID_ESTADO_BAJA INT;
    /*excepción para hacer rolLback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, sino
    en alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20011' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de BAJA DEL USUARIO";
    END;

    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_USR_RESP));
        IF(@PRIVILEGIOS=1) THEN
            /*RECUPERO EL ID DEL ESTADO "BAJA" CON UNA FUNCIÓN*/
            SET ID_ESTADO_BAJA=(SELECT FUNCT_DEVOLVER_ESTADO_USR_BAJA());
            /*valido si existe el usuario responsable de la gestión,
            SI existe y tiene rol de admin y está activo, devuelve 1, sino 0*/
            SET VALIDAR_ROL=(SELECT FUNCT_EXISTE_USR_ADMIN (NIP_USR_RESP));
            IF(VALIDAR_ROL=1) THEN
                UPDATE USUARIO_SISTEMA SET ID_ESTADO_USR=ID_ESTADO_BAJA WHERE ID_USUARIO=NIP_FIJO;
                UPDATE USUARIO_SISTEMA SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_USUARIO=NIP_FIJO;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20012' SET MESSAGE_TEXT = "El usuario no tiene privilegios, o no existe
                en la base de datos o está inactivo";
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20013' SET MESSAGE_TEXT="¡Usted no tiene privilegios para realizar esta acción!";
        END IF;
    END// DELIMITER;

/**/ 
/*CALL PA_BAJA_USR_SISTEMA(1754,1751);*/


/*Procedimiento almacenado para guardar el último ingreso al sistema por parte del usuario*/
DROP PROCEDURE IF EXISTS PA_ACTUALIZACION_ULTIMO_LOGIN; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZACION_ULTIMO_LOGIN`(IN NIP_FIJO INT,IN NIP_USR_RESP INT)
BEGIN
    /*excepción para hacer rolback si surge una excepción de sql durante la 
    ejecución de alguna consulta*/
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20015' SET MESSAGE_TEXT = "ERROR AL GRABAR LA ACTUALIZACION, COMUNIQUESE CON EL DBA";
    END;
    /*excepción para hacer rolback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, SINO
    EN alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20016' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de usuario";
    END;

    START TRANSACTION;
            UPDATE USUARIO_SISTEMA SET ULTIMO_LOGIN=NOW() WHERE ID_USUARIO=NIP_FIJO;
            UPDATE USUARIO_SISTEMA SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_USUARIO=NIP_FIJO;
    COMMIT;

END// DELIMITER;


/*******************************************************************************/
                        /*TRIGGERS CRUD USUARIO */
/*******************************************************************************/


/*TRIGGER PARA REGISTRAR LA CREACIÓN DE UN USUARIO (INSERCIÓN DE USUARIO), SOLO 
SE ALMACENA EL "MOVIMIENTO" YA EN LA ACTUALIZACIÓN DE DATOS, SERÁ OTRO TRIGGER
 QUE SE DISPARARÁ*/
DROP TRIGGER IF EXISTS AI_USUARIO_SISTEMA;
DELIMITER// 
/*Trigger para registar la creación de un nuevo usuario*/
CREATE DEFINER=`root`@`localhost` TRIGGER AI_USUARIO_SISTEMA
    AFTER INSERT ON USUARIO_SISTEMA
    FOR EACH ROW
    BEGIN
      INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
      FECHA_MOVIMIENTO,ID_USR_RESPONSABLE)
      VALUES(new.ID_USUARIO,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR);
  	END// DELIMITER;


/*Trigger para registar la actualización de los datos de un usuario,
esto se hará después de la actualización de datos de este*/
DROP TRIGGER IF EXISTS AU_USUARIO_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` TRIGGER AU_USUARIO_SISTEMA
AFTER UPDATE ON USUARIO_SISTEMA
FOR EACH ROW
BEGIN 
    /*Variable para capturar el nombre del estado del usuario
    que se está modificando*/    
    DECLARE ESTADO_USR VARCHAR(100);
    /*en las comparaciones adicionales new.variable<>old.variable
    estamos registrando únicamente los movimientos cuando las variables
    son alteradas de valor, es decir, cambian.*/
    IF(NEW.NOMBRES IS NOT NULL AND NEW.NOMBRES<>OLD.NOMBRES) THEN  
            INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_USUARIO,5,2,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.NOMBRES,new.NOMBRES);

    ELSEIF(NEW.APELLIDOS IS NOT NULL AND NEW.APELLIDOS<>OLD.APELLIDOS) THEN
            INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO) 
            VALUES(new.ID_USUARIO,5,3,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.APELLIDOS,new.APELLIDOS);
            
    ELSEIF(NEW.ID_ESTADO_USR IS NOT NULL AND NEW.ID_ESTADO_USR<>OLD.ID_ESTADO_USR) THEN
        /*veo a que valor coincide el nuevo estado del usuario*/
        SELECT NOMBRE INTO ESTADO_USR FROM ESTADO_USUARIO 
        WHERE ID_ESTADO_USR=NEW.ID_ESTADO_USR LIMIT 1;
        /*si el usuario de estar inactivo pasa a activo*/
        IF (ESTADO_USR='ACTIVO') THEN
            INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_USUARIO,5,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_USR,new.ID_ESTADO_USR);        
        /*SI EL USUARIO PASARÁ A INACTIVO, EN LA BITÁCORA REGISTRAMOS QUE EL TIPO DE 
        MOVIMIENTO = 3 QUE PERTENECE A "BAJA" DEL SISTEMA (NO ES BORRADO)*/    
        ELSEIF(ESTADO_USR='INACTIVO') THEN
            INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_USUARIO,5,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_USR,new.ID_ESTADO_USR);        
            /*si el usuario pasa de cualquiera de los dos estados
            anteriores a estado de baja (no será visible más por el usuario, solo por el dba)*/
            ELSEIF(ESTADO_USR='BAJA') THEN
            INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_USUARIO,6,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_USR,new.ID_ESTADO_USR);        
        END IF;

    ELSEIF(NEW.ID_ROL IS NOT NULL AND NEW.ID_ROL<>OLD.ID_ROL) THEN
        INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_USUARIO,5,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ROL,new.ID_ROL);
    
    ELSEIF(NEW.ACCESO IS NOT NULL AND NEW.ACCESO<>OLD.ACCESO) THEN
        INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_USUARIO,5,6,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ACCESO,new.ACCESO);

    ELSEIF(NEW.ULTIMO_LOGIN IS NOT NULL AND NEW.ULTIMO_LOGIN<>OLD.ULTIMO_LOGIN) THEN
        INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_USUARIO,5,7,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ULTIMO_LOGIN,new.ULTIMO_LOGIN);
    /*SOLO REGISTRO EL UDPATE DE ULTIMO USUARIO MODIFICADOR CUANDO CAMBIE, SE ENVIA AL TRIGGER CON
    EL OBJETIVO DE HACER LA INSERCIÓN DEL NIP EN LOS OTROS CAMPOS CUANDO SE NECESITA (REGISTRAR QUE USUARIO HIZO
    EL MOVIMIENTO)*/
    ELSEIF(NEW.ULTIMO_USUARIO_MODIFICADOR IS NOT NULL  AND NEW.ULTIMO_USUARIO_MODIFICADOR<>OLD.ULTIMO_USUARIO_MODIFICADOR) THEN
         INSERT INTO BITACORA_USUARIO(ID_USR_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_USUARIO,5,8,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ULTIMO_USUARIO_MODIFICADOR,new.ULTIMO_USUARIO_MODIFICADOR);
    END IF;
END// DELIMITER;



/*******************************************************************************/
                        /* CRUD PERITO*/
/*******************************************************************************/
/*******************************************************************************/
                        /*VISTA CRUD PERITO */
/*******************************************************************************/

/*VISTA PARA MOSTRAR AL USUARIO FINAL EN EL FRONTEND LOS DATOS QUE PODRÁ MODIFICAR,
A EXCEPCION DEL ID_USUARIO (NIP)*/
DROP VIEW IF EXISTS VISTA_CRUD_PERITO;
DELIMITER//
CREATE VIEW VISTA_CRUD_PERITO
(NIP,NOMBRES,APELLIDOS,ESTADO_PERITO)
AS
(SELECT  PER.ID_PERITO,PER.NOMBRES,PER.APELLIDOS,EP.NOMBRE FROM PERITO PER 
INNER JOIN ESTADO_PERITO EP
ON PER.ID_ESTADO_PERITO=EP.ID_ESTADO_PERITO AND EP.NOMBRE<>'BAJA');
//DELIMITER;


/*******************************************************************************/
                        /*FUNCIONES CRUD PERITO */
/*******************************************************************************/
/*función para determinar si existe ya un PERITO con el nip en el sistema*/
DROP FUNCTION IF EXISTS FUNCT_EXISTE_PERITO_SISTEMA;
DELIMITER //
CREATE FUNCTION FUNCT_EXISTE_PERITO_SISTEMA(NIP_NUEVO INT) RETURNS INT
BEGIN
    SET @VERIFICAR_ID_USR=(SELECT COUNT(*) FROM PERITO WHERE ID_PERITO=NIP_NUEVO);

    IF(@VERIFICAR_ID_USR>0) THEN
        RETURN @VERIFICAR_ID_USR;
    ELSE
        RETURN @VERIFICAR_ID_USR;
    END IF;
END// DELIMITER;



/*FUNCION PARA DEVOLVER EL ID DEL TIPO DE "ESTADO BAJA"*/
DROP FUNCTION IF EXISTS FUNCT_DEVOLVER_ESTADO_PER_BAJA;
DELIMITER //
CREATE FUNCTION FUNCT_DEVOLVER_ESTADO_PER_BAJA() RETURNS INT(03)
BEGIN
    DECLARE ID_ESTADO_BAJA INT;
    SET ID_ESTADO_BAJA=(SELECT ID_ESTADO_PERITO FROM ESTADO_PERITO WHERE NOMBRE="BAJA" LIMIT 1);

    IF(ID_ESTADO_BAJA!='') THEN
        RETURN ID_ESTADO_BAJA;
    ELSE
        SIGNAL SQLSTATE '20029' SET MESSAGE_TEXT = "ERROR AL BUSCAR EL ESTADO DE USUARIO, CONTACTE AL DBA";
    END IF;
END// DELIMITER;





/*******************************************************************************/
                        /*PROCEDIMIENTOS ALMACENADOS CRUD PERITO */
/*******************************************************************************/

/*PROCEDIMIENTO ALMACENADO PARA LA CREACIÓN DE UN PERITO*/
DROP PROCEDURE IF EXISTS PA_CREAR_PERITO_SISTEMA;
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_CREAR_PERITO_SISTEMA`(IN NIP_NUEVO INT, IN NOMBRES_USR_NUEVO VARCHAR(200),IN APELLIDOS_USR_NUEVO VARCHAR(100),IN NIP_ULT_USR_MOD INT,IN NOMBRE_ROL_USR_RESP VARCHAR(100))
BEGIN
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20020' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de creación de PERITO";
    END;
    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR AL PERITO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            /*VERIFICAMOS SI EL PERITO EXISTE EN EL SISTEMA*/
            SET @EXISTE_PERITO = (SELECT FUNCT_EXISTE_PERITO_SISTEMA(NIP_NUEVO));
            IF(@EXISTE_PERITO=0) THEN
                /*EVALUAMOS QUE EL ROL EXISTE EN LA BD Y EXTRAEMOS EL ID DE ESTE*/
                SET @NROL_USUARIO_MOD=(SELECT ID_ROL FROM ROL_USUARIO
                WHERE DESCRIPCION=NOMBRE_ROL_USR_RESP LIMIT 1);
                /*SI NO NOS DEVUELVE NULL ó 0*/ 
                IF(@NROL_USUARIO_MOD IN(4,5,6)) THEN
                    INSERT INTO PERITO VALUES(NIP_NUEVO,NOMBRES_USR_NUEVO,APELLIDOS_USR_NUEVO,NOW(),4,NIP_ULT_USR_MOD);
                ELSE
                SIGNAL SQLSTATE '20017' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
                END IF;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20018' SET MESSAGE_TEXT = 'El PERITO ya existe, sino lo observa en la tabla, comuníquese con el desarrollador';
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20019' SET MESSAGE_TEXT='¡Usted no tiene privilegios de Administrador!';
            ROLLBACK;
        END IF;
END;




/*procedimiento almacenado para la actualización de datos de un perito*/
DROP PROCEDURE IF EXISTS PA_ACTUALIZAR_PERITO_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZAR_PERITO_SISTEMA`(IN NIP_FIJO INT, IN NOMBRES_USR_EDITAR VARCHAR(100),
IN APELLIDOS_USR_EDITAR VARCHAR(100),IN NIP_ULT_USR_MOD INT,IN NOMBRE_ROL_USR_RESP VARCHAR(100))
BEGIN
    /*variables para capturar los datos recuperados de la bd del perito
    a través de un cursor*/
    DECLARE C_NIP INT(10);
    DECLARE C_NOMBRES VARCHAR(200);
    DECLARE C_APELLIDOS VARCHAR(200);
    DECLARE C_NIP_ULT_USR_MODIFICADOR INT(10);
    /*variable para cerrar el loop*/
    DECLARE FIN_LOOP INTEGER DEFAULT 0;
    /*creo un cursor para recuperar los datos del perito a actualizar (datos)*/
    DECLARE CURSOR_SELECCION_PERITO CURSOR FOR
    SELECT ID_PERITO,NOMBRES,APELLIDOS,ULTIMO_USUARIO_MODIFICADOR
    FROM PERITO WHERE ID_PERITO=NIP_FIJO;

    /*VARIABLE PARA CONTROLAR EL FINAL DE RECORRIDO DEL CURSOR*/
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIN_LOOP=1; 
    /*excepción para hacer rolback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, SINO
    EN alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20021' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de perito";
    END;

    START TRANSACTION;

        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            /*EVALUAMOS QUE EL ROL EXISTE EN LA BD*/
            SET @NROL_USUARIO=(SELECT ID_ROL FROM ROL_USUARIO 
            WHERE DESCRIPCION=NOMBRE_ROL_USR_RESP LIMIT 1);
            /*SI EL ID DE ROL DE USUARIO SE ENCUENTRA en el de rol DE ADMIN*/ 
            IF(@NROL_USUARIO IN(4)) THEN
                /*abrimos el cursor*/
                OPEN CURSOR_SELECCION_PERITO;
                    CICLO: LOOP
                    FETCH CURSOR_SELECCION_PERITO INTO C_NIP,C_NOMBRES, C_APELLIDOS,
                    C_NIP_ULT_USR_MODIFICADOR;
                        /*comprobamos si llegamos al final de los registros obtenidos del cursor*/
                        IF FIN_LOOP = 1 THEN
                            LEAVE CICLO;
                        END IF;
                        /*HARÉ VALIDACIÓN DE CAMPO POR CAMPO PARA IDENTIFICAR SI VARIA EL VALOR ANTIGUO
                        DE CADA UNO CON EL NUEVO ENVIADO POR EL USUARIO DESDE LA VISTA*/
                        /*SI SE ACTUALIZA EL NOMBRE DEL USUARIO*/
                        IF(NOMBRES_USR_EDITAR<>C_NOMBRES) THEN
                            UPDATE PERITO SET NOMBRES=NOMBRES_USR_EDITAR WHERE ID_PERITO=NIP_FIJO;
                        END IF;
                        /*SI LOS APELLIDOS O APELLIDO SON O ES ACTUALIZADO*/
                        IF(APELLIDOS_USR_EDITAR<>C_APELLIDOS) THEN
                            UPDATE PERITO SET APELLIDOS=APELLIDOS_USR_EDITAR WHERE ID_PERITO=NIP_FIJO;
                        END IF;
                        /*DEBEMOS REGISTAR QUE USUARIO CON PRIVILEGIOS DE ADMIN 
                        FUE EL ÚLITMO EN EDITAR A OTRO USUARIO*/
                        IF(C_NIP_ULT_USR_MODIFICADOR<>NIP_ULT_USR_MOD) THEN
                            UPDATE PERITO SET ULTIMO_USUARIO_MODIFICADOR=C_NIP_ULT_USR_MODIFICADOR
                            WHERE ID_PERITO=NIP_FIJO;
                        END IF;         
                    END LOOP CICLO;
                CLOSE CURSOR_SELECCION_PERITO;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20022' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
            ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20023' SET MESSAGE_TEXT = '¡USTED NO TIENE PRIVILEGIOS PARA RELIZAR ESTAS ACCIONES!';
        END IF;    
END// DELIMITER;



/*Procedimiento Almacenado para la actualización de estado de un perito*/
/*Recibe como parámetros el nip del perito a modificar el estado, el estado nuevo (activo, inactivo)
y el NIP del usuario logueado que hace la modificación del estado*/
DROP PROCEDURE  IF EXISTS PA_ACTUALIZACION_ESTADO_PER;
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZACION_ESTADO_PER`(IN NIP_FIJO INT, IN ESTADO_USUARIO INT,IN NIP_USR_RESP INT)
BEGIN
    /*excepción para hacer rolLback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, sino
    en alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20024' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de estado del perito";
    END;

    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_USR_RESP));
        IF(@PRIVILEGIOS=1) THEN
            UPDATE PERITO SET ID_ESTADO_PERITO=ESTADO_USUARIO WHERE ID_PERITO=NIP_FIJO;
            UPDATE PERITO SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_PERITO=NIP_FIJO;
            commit;
        ELSE
            SIGNAL SQLSTATE '20025' SET MESSAGE_TEXT = "¡Usted no tiene privilegios de Administrador!";
            ROLLBACK;
        END IF;
    COMMIT;
    END// DELIMITER;




/*PROCEDIMIENTO ALMACENAOD PARA DAR DE BAJA A UN PERITO DEL SISTEMA*/
DROP PROCEDURE  IF EXISTS PA_BAJA_PER_SISTEMA;
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_BAJA_PER_SISTEMA`(IN NIP_FIJO INT,IN NIP_USR_RESP INT)
BEGIN
    /*Variable para determinar si el usuario que quiere hacer el UPDATE 
    existe en la bd, y tiene rol de administrador*/
    DECLARE VALIDAR_ROL INT;
    /*Variable para recuperar el id del estado "baja"*/
    DECLARE ID_ESTADO_BAJA INT;
    /*excepción para hacer rolLback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, sino
    en alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20026' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de BAJA DEL PERITO";
    END;

    START TRANSACTION;
        /*VERIFICAMOS SI EL PERITO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_USR_RESP));
        IF(@PRIVILEGIOS=1) THEN
            /*RECUPERO EL ID DEL ESTADO "BAJA" CON UNA FUNCIÓN*/
            SET ID_ESTADO_BAJA=(SELECT FUNCT_DEVOLVER_ESTADO_PER_BAJA());
            /*valido si existe el usuario responsable de la gestión,
            SI existe y tiene rol de admin y está activo, devuelve 1, sino 0*/
            SET VALIDAR_ROL=(SELECT FUNCT_EXISTE_USR_ADMIN (NIP_USR_RESP));
            IF(VALIDAR_ROL=1) THEN
                UPDATE PERITO SET ID_ESTADO_PERITO=ID_ESTADO_BAJA WHERE ID_PERITO=NIP_FIJO;
                UPDATE PERITO SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_PERITO=NIP_FIJO;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20027' SET MESSAGE_TEXT = "El usuario no tiene privilegios, o no existe
                en la base de datos o está inactivo";
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20028' SET MESSAGE_TEXT="¡Usted no tiene privilegios para realizar esta acción!";
        END IF;
    END// DELIMITER;



/*******************************************************************************/
                        /*TRIGGERS CRUD PERITO */
/*******************************************************************************/

/*TRIGGER PARA REGISTRAR LA CREACIÓN DE UN PERITO (INSERCIÓN DE PERITO), SOLO 
SE ALMACENA EL "MOVIMIENTO" YA EN LA ACTUALIZACIÓN DE DATOS, SERÁ OTRO TRIGGER
 QUE SE DISPARARÁ*/
DROP TRIGGER IF EXISTS AI_PERITO_SISTEMA;
DELIMITER// 
/*Trigger para registar la creación de un nuevo usuario*/
CREATE DEFINER=`root`@`localhost` TRIGGER AI_PERITO_SISTEMA
    AFTER INSERT ON PERITO
    FOR EACH ROW
    BEGIN
      INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
      FECHA_MOVIMIENTO,ID_USR_RESPONSABLE)
      VALUES(new.ID_PERITO,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR);
  	END// DELIMITER;



/*Trigger para registar la actualización de los datos de un perito,
esto se hará después de la actualización de datos de este*/
DROP TRIGGER IF EXISTS AU_PERITO_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` TRIGGER AU_PERITO_SISTEMA
AFTER UPDATE ON PERITO
FOR EACH ROW
BEGIN 
    /*Variable para capturar el nombre del estado del PERITO
    que se está modificando*/    
    DECLARE ESTADO_PER VARCHAR(100);
    /*en las comparaciones adicionales new.variable<>old.variable
    estamos registrando únicamente los movimientos cuando las variables
    son alteradas de valor, es decir, cambian.*/
    IF(NEW.NOMBRES IS NOT NULL AND NEW.NOMBRES<>OLD.NOMBRES) THEN  
            INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_PERITO,5,2,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.NOMBRES,new.NOMBRES);

    ELSEIF(NEW.APELLIDOS IS NOT NULL AND NEW.APELLIDOS<>OLD.APELLIDOS) THEN
            INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO) 
            VALUES(new.ID_PERITO,5,3,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.APELLIDOS,new.APELLIDOS);
            
    ELSEIF(NEW.ID_ESTADO_PERITO IS NOT NULL AND NEW.ID_ESTADO_PERITO<>OLD.ID_ESTADO_PERITO) THEN
        /*veo a que valor coincide el nuevo estado del perito*/
        SELECT NOMBRE INTO ESTADO_PER FROM ESTADO_PERITO 
        WHERE ID_ESTADO_PERITO=NEW.ID_ESTADO_PERITO LIMIT 1;
        /*si el perito de estar inactivo pasa a activo*/
        IF (ESTADO_PER='ACTIVO') THEN
            INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_PERITO,5,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_PERITO,new.ID_ESTADO_PERITO);        
        /*SI EL USUARIO PASARÁ A INACTIVO, EN LA BITÁCORA REGISTRAMOS QUE EL TIPO DE 
        MOVIMIENTO = 3 QUE PERTENECE A "BAJA" DEL SISTEMA (NO ES BORRADO)*/    
        ELSEIF(ESTADO_PER='INACTIVO') THEN
            INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_PERITO,5,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_PERITO,new.ID_ESTADO_PERITO);        
            /*si el perito pasa de cualquiera de los dos estados
            anteriores a estado de baja (no será visible más por el usuario, solo por el dba)*/
            ELSEIF(ESTADO_PER='BAJA') THEN
            INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_PERITO,6,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_PERITO,new.ID_ESTADO_PERITO);        
        END IF;
    /*SOLO REGISTRO EL UDPATE DE ULTIMO USUARIO MODIFICADOR CUANDO CAMBIE, SE ENVIA AL TRIGGER CON
    EL OBJETIVO DE HACER LA INSERCIÓN DEL NIP EN LOS OTROS CAMPOS CUANDO SE NECESITA (REGISTRAR QUE USUARIO HIZO
    EL MOVIMIENTO)*/
    ELSEIF(NEW.ULTIMO_USUARIO_MODIFICADOR IS NOT NULL  AND NEW.ULTIMO_USUARIO_MODIFICADOR<>OLD.ULTIMO_USUARIO_MODIFICADOR) THEN
         INSERT INTO BITACORA_PERITO(ID_PERITO_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_PERITO,5,6,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ULTIMO_USUARIO_MODIFICADOR,new.ULTIMO_USUARIO_MODIFICADOR);
    END IF;
END// DELIMITER;




/*********************************************************************************/
                                        /*CRUD SECCION*/
/********************************************************************************/

/*********************************************************************************/
                                        /*VISTA CRUD SECCION*/
/********************************************************************************/
USE TFM;
DROP VIEW IF EXISTS VISTA_CRUD_SECCION;
DELIMITER //
CREATE VIEW VISTA_CRUD_SECCION
(ID,NOMBRES,IDENTIFICADOR,ESTADO_SECCION)
AS
(SELECT SEC.ID_SECCION,SEC.NOMBRE,SEC.IDENTIFICADOR,ES.NOMBRE AS ESTADO_SECCION FROM SECCION SEC
INNER JOIN ESTADO_SECCION ES ON SEC.ID_ESTADO_SECCION=ES.ID_ESTADO_SECCION AND ES.NOMBRE<>'BAJA');
// DELIMITER;
select * from seccion;
select * from estado_seccion;
/*********************************************************************************/
                                        /*FUNCIONES CRUD SECCION*/
/********************************************************************************/

/*FUNCION PARA DEVOLVER EL ID DEL TIPO DE "ESTADO BAJA"*/
DROP FUNCTION IF EXISTS FUNCT_DEVOLVER_ESTADO_SECC_BAJA;
DELIMITER //
CREATE FUNCTION FUNCT_DEVOLVER_ESTADO_SECC_BAJA() RETURNS INT(03)
BEGIN
    DECLARE ID_ESTADO_BAJA INT;
    SET ID_ESTADO_BAJA=(SELECT ID_ESTADO_SECCION FROM ESTADO_SECCION WHERE NOMBRE="BAJA" LIMIT 1);

    IF(ID_ESTADO_BAJA!='') THEN
        RETURN ID_ESTADO_BAJA;
    ELSE
        SIGNAL SQLSTATE '20038' SET MESSAGE_TEXT = "ERROR AL BUSCAR EL ESTADO DE SECCION, CONTACTE AL DBA";
    END IF;
END// DELIMITER;


/*******************************************************************************/
                        /*PROCEDIMIENTOS ALMACENADOS CRUD PERITO */
/*******************************************************************************/

/*PROCEDIMIENTO ALMACENADO PARA LA CREACIÓN DE UNA SECCION*/
DROP PROCEDURE IF EXISTS PA_CREAR_SECCION_SISTEMA;
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_CREAR_SECCION_SISTEMA`(IN NOMBRE_NUEVO VARCHAR(100),IN IDENTIFICADOR_NUEVO VARCHAR(10),IN NIP_ULT_USR_MOD INT,IN NOMBRE_ROL_USR_RESP VARCHAR(100))
BEGIN
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20029' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de creación de PERITO";
    END;
    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR AL PERITO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            
                /*EVALUAMOS QUE EL ROL EXISTE EN LA BD Y EXTRAEMOS EL ID DE ESTE*/
                SET @NROL_USUARIO_MOD=(SELECT ID_ROL FROM ROL_USUARIO
                WHERE DESCRIPCION=NOMBRE_ROL_USR_RESP LIMIT 1);
                /*SI EL ROL DE USUARIO ES ÚNICAMENTE ADMINISTRADOR*/ 
                IF(@NROL_USUARIO_MOD IN(4)) THEN
                    INSERT INTO SECCION(NOMBRE,IDENTIFICADOR,ULTIMO_USUARIO_MODIFICADOR,ID_ESTADO_SECCION) VALUES(NOMBRE_NUEVO,IDENTIFICADOR_NUEVO,NIP_ULT_USR_MOD,1);
                ELSE
                SIGNAL SQLSTATE '20030' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
                END IF;
                COMMIT;
        ELSE
            SIGNAL SQLSTATE '20031' SET MESSAGE_TEXT='¡Usted no tiene privilegios de Administrador!';
            ROLLBACK;
        END IF;
END;




/*procedimiento almacenado para la actualización de datos de una sección*/
DROP PROCEDURE IF EXISTS PA_ACTUALIZAR_SECCION_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZAR_SECCION_SISTEMA`(IN ID_SECCION_EDITAR INT, IN NOMBRES_SEC_EDITAR VARCHAR(100),
IN IDENTIFICADOR_EDITAR VARCHAR(100),IN NIP_ULT_USR_MOD INT,IN NOMBRE_ROL_USR_RESP VARCHAR(100))
BEGIN
    /*variables para capturar los datos recuperados de la bd del perito
    a través de un cursor*/
    DECLARE C_ID_SECCION INT(10);
    DECLARE C_NOMBRE VARCHAR(200);
    DECLARE C_IDENTIFICADOR VARCHAR(200);
    DECLARE C_ID_SECCION_ULT_USR_MODIFICADOR INT(10);
    /*variable para cerrar el loop*/
    DECLARE FIN_LOOP INTEGER DEFAULT 0;
    /*creo un cursor para recuperar los datos del perito a actualizar (datos)*/
    DECLARE CURSOR_SELECCION_SECCION CURSOR FOR
    SELECT ID_SECCION,NOMBRE,IDENTIFICADOR,ULTIMO_USUARIO_MODIFICADOR
    FROM SECCION WHERE ID_SECCION=ID_SECCION_EDITAR;

    /*VARIABLE PARA CONTROLAR EL FINAL DE RECORRIDO DEL CURSOR*/
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIN_LOOP=1; 
    /*excepción para hacer rolback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, SINO
    EN alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20032' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de perito";
    END;

    START TRANSACTION;

        /*VERIFICAMOS SI EL USUARIO QUE QUIERE EDITAR LA SECCIÓN ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            /*EVALUAMOS QUE EL ROL EXISTE EN LA BD*/
            SET @NROL_USUARIO=(SELECT ID_ROL FROM ROL_USUARIO 
            WHERE DESCRIPCION=NOMBRE_ROL_USR_RESP LIMIT 1);
            /*SI EL ID DE ROL DE USUARIO SE ENCUENTRA en el de rol DE ADMIN*/ 
            IF(@NROL_USUARIO IN(4)) THEN
                /*abrimos el cursor*/
                OPEN CURSOR_SELECCION_SECCION;
                    CICLO: LOOP
                    FETCH CURSOR_SELECCION_SECCION INTO C_ID_SECCION,C_NOMBRE, C_IDENTIFICADOR,
                    C_ID_SECCION_ULT_USR_MODIFICADOR;
                        /*comprobamos si llegamos al final de los registros obtenidos del cursor*/
                        IF FIN_LOOP = 1 THEN
                            LEAVE CICLO;
                        END IF;
                        /*HARÉ VALIDACIÓN DE CAMPO POR CAMPO PARA IDENTIFICAR SI VARIA EL VALOR ANTIGUO
                        DE CADA UNO CON EL NUEVO ENVIADO POR EL USUARIO DESDE LA VISTA*/
                        /*SI SE ACTUALIZA EL NOMBRE DE SECCION*/
                        IF(NOMBRES_SEC_EDITAR<>C_NOMBRE) THEN
                            UPDATE SECCION SET NOMBRE=NOMBRES_SEC_EDITAR WHERE ID_SECCION=ID_SECCION_EDITAR;
                        END IF;
                        /*SI EL IDENTIFICADOR ES ACTUALIZADO*/
                        IF(IDENTIFICADOR_EDITAR<>C_IDENTIFICADOR) THEN
                            UPDATE SECCION SET IDENTIFICADOR=IDENTIFICADOR_EDITAR WHERE ID_SECCION=ID_SECCION_EDITAR;
                        END IF;
                        /*DEBEMOS REGISTAR QUE USUARIO CON PRIVILEGIOS DE ADMIN 
                        FUE EL ÚLITMO EN EDITAR A OTRO USUARIO*/
                        IF(C_ID_SECCION_ULT_USR_MODIFICADOR<>NIP_ULT_USR_MOD) THEN
                            UPDATE SECCION SET ULTIMO_USUARIO_MODIFICADOR=NIP_ULT_USR_MOD
                            WHERE ID_SECCION=ID_SECCION_EDITAR;
                        END IF;         
                    END LOOP CICLO;
                CLOSE CURSOR_SELECCION_SECCION;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20033' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
            ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20034' SET MESSAGE_TEXT = '¡USTED NO TIENE PRIVILEGIOS PARA RELIZAR ESTAS ACCIONES!';
        END IF;    
END// DELIMITER;



/*PROCEDIMIENTO ALMACENAOD PARA DAR DE BAJA A UNA SECCION DEL SISTEMA*/
DROP PROCEDURE  IF EXISTS PA_BAJA_SEC_SISTEMA;
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_BAJA_SEC_SISTEMA`(IN ID_SECCION_FIJA INT,IN NIP_USR_RESP INT)
BEGIN
    /*Variable para determinar si el usuario que quiere hacer el UPDATE 
    existe en la bd, y tiene rol de administrador*/
    DECLARE VALIDAR_ROL INT;
    /*Variable para recuperar el id del estado "baja"*/
    DECLARE ID_ESTADO_BAJA INT;
    /*excepción para hacer rolLback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, sino
    en alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20035' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de BAJA DEL PERITO";
    END;

    START TRANSACTION;
        /*VERIFICAMOS SI EL PERITO QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_USR_RESP));
        IF(@PRIVILEGIOS=1) THEN
            /*RECUPERO EL ID DEL ESTADO "BAJA" CON UNA FUNCIÓN*/
            SET ID_ESTADO_BAJA=(SELECT FUNCT_DEVOLVER_ESTADO_SECC_BAJA());
            IF(!ISNULL(ID_ESTADO_BAJA)) THEN
                UPDATE SECCION SET ID_ESTADO_SECCION=ID_ESTADO_BAJA WHERE ID_SECCION=ID_SECCION_FIJA;
                UPDATE SECCION SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_SECCION=ID_SECCION_FIJA;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20036' SET MESSAGE_TEXT = "OPCION INEXISTENTE AL QUERER ELIMINAR SECCION, COMÚNIQUESE CON EL DESARROLLADOR";
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20037' SET MESSAGE_TEXT="¡Usted no tiene privilegios para realizar esta acción!";
        END IF;
    END// DELIMITER;

/*******************************************************************************/
                        /*TRIGGERS CRUD SECCION */
/*******************************************************************************/

/*TRIGGER PARA REGISTRAR LA CREACIÓN DE UN SECCION (INSERCIÓN DE SECCION), SOLO 
SE ALMACENA EL "MOVIMIENTO" YA EN LA ACTUALIZACIÓN DE DATOS, SERÁ OTRO TRIGGER
 QUE SE DISPARARÁ*/
DROP TRIGGER IF EXISTS AI_SECCION_SISTEMA;
DELIMITER// 
/*Trigger para registar la creación de una nueva sección*/
CREATE DEFINER=`root`@`localhost` TRIGGER AI_SECCION_SISTEMA
    AFTER INSERT ON SECCION
    FOR EACH ROW
    BEGIN
      INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
      FECHA_MOVIMIENTO,ID_USR_RESPONSABLE)
      VALUES(new.ID_SECCION,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR);
  	END// DELIMITER;



/*Trigger para registar la actualización de los datos de un perito,
esto se hará después de la actualización de datos de este*/
DROP TRIGGER IF EXISTS AU_SECCION_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` TRIGGER AU_SECCION_SISTEMA
AFTER UPDATE ON SECCION
FOR EACH ROW
BEGIN 
    /*Variable para capturar el nombre del estado de la sección
    que se está modificando*/    
    DECLARE ESTADO_SECCIONN VARCHAR(100);
    /*en las comparaciones adicionales new.variable<>old.variable
    estamos registrando únicamente los movimientos cuando las variables
    son alteradas de valor, es decir, cambian.*/
    IF(NEW.NOMBRE IS NOT NULL AND NEW.NOMBRE<>OLD.NOMBRE) THEN  
            INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_SECCION,5,2,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.NOMBRE,new.NOMBRE);

    ELSEIF(NEW.IDENTIFICADOR IS NOT NULL AND NEW.IDENTIFICADOR<>OLD.IDENTIFICADOR) THEN
            INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO) 
            VALUES(new.ID_SECCION,5,3,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.IDENTIFICADOR,new.IDENTIFICADOR);
            
    ELSEIF(NEW.ID_ESTADO_SECCION IS NOT NULL AND NEW.ID_ESTADO_SECCION<>OLD.ID_ESTADO_SECCION) THEN
        /*veo a que valor coincide el nuevo estado de LA SECCION*/
        SELECT NOMBRE INTO ESTADO_SECCIONN FROM ESTADO_SECCION 
        WHERE ID_ESTADO_SECCION=NEW.ID_ESTADO_SECCION LIMIT 1;
        /*si el perito de estar inactivo pasa a activo*/
        IF (ESTADO_SECCIONN='ACTIVO') THEN
            INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_SECCION,5,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_SECCION,new.ID_ESTADO_SECCION);        
        /*SI LA SECCION PASARÁ A BORRADO, EN LA BITÁCORA REGISTRAMOS QUE EL TIPO DE 
        MOVIMIENTO =6 QUE PERTENECE A "BAJA" DEL SISTEMA (NO ES BORRADO)*/    
        ELSEIF(ESTADO_SECCIONN='INACTIVO') THEN
            INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_SECCION,5,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_SECCION,new.ID_ESTADO_SECCION);        
            /*si el perito pasa de cualquiera de los dos estados
            anteriores a estado de baja (no será visible más por el usuario, solo por el dba)*/
            ELSEIF(ESTADO_SECCIONN='BAJA') THEN
            INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_SECCION,6,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_SECCION,new.ID_ESTADO_SECCION);        
        END IF;
    /*SOLO REGISTRO EL UDPATE DE ULTIMO USUARIO MODIFICADOR CUANDO CAMBIE, SE ENVIA AL TRIGGER CON
    EL OBJETIVO DE HACER LA INSERCIÓN DEL NIP EN LOS OTROS CAMPOS CUANDO SE NECESITA (REGISTRAR QUE USUARIO HIZO
    EL MOVIMIENTO)*/
    ELSEIF(NEW.ULTIMO_USUARIO_MODIFICADOR IS NOT NULL  AND NEW.ULTIMO_USUARIO_MODIFICADOR<>OLD.ULTIMO_USUARIO_MODIFICADOR) THEN
         INSERT INTO BITACORA_SECCION(ID_SEC_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_SECCION,5,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ULTIMO_USUARIO_MODIFICADOR,new.ULTIMO_USUARIO_MODIFICADOR);
    END IF;
END// DELIMITER;



/*********************************************************************************/
                                        /*CRUD TIPO_GESTION*/
/********************************************************************************/

/*********************************************************************************/
                                        /*VISTA CRUD TIPO_GESTION*/
/********************************************************************************/
USE TFM;
DROP VIEW IF EXISTS VISTA_CRUD_TIPO_GESTION;
DELIMITER //
CREATE VIEW VISTA_CRUD_TIPO_GESTION
(ID,NOMBRES,CLASE_GESTION,ESTADO_TIPO_GESTION)
AS
(SELECT TG.ID_TIPO_GESTION,TG.NOMBRE AS NOMBRE_GESTION,CG.NOMBRE AS CLASE_GESTION,ETG.NOMBRE AS ESTADO_GESTION
FROM TIPO_GESTION TG INNER JOIN CLASE_GESTION CG
ON TG.ID_CLASE_GESTION=CG.ID_CLASE_GESTION
INNER JOIN ESTADO_TIPO_GESTION ETG
ON TG.ID_ESTADO_TIPO_GESTION = ETG.ID_ESTADO_TIPO_GESTION AND ETG.NOMBRE <>'BAJA');
// DELIMITER;



/*********************************************************************************/
                                        /*FUNCIONES CRUD TIPO_GESTION*/
/********************************************************************************/

/*FUNCION PARA DEVOLVER EL ID DEL TIPO DE "ESTADO BAJA"*/
DROP FUNCTION IF EXISTS FUNCT_DEVOLVER_ESTADO_TIPOGESTION_BAJA;
DELIMITER //
CREATE FUNCTION FUNCT_DEVOLVER_ESTADO_TIPOGESTION_BAJA() RETURNS INT(03)
BEGIN
    DECLARE ID_ESTADO_BAJA INT;
    SET ID_ESTADO_BAJA=(SELECT ID_ESTADO_TIPO_GESTION FROM ESTADO_TIPO_GESTION WHERE NOMBRE="BAJA" LIMIT 1);

    IF(ID_ESTADO_BAJA!='') THEN
        RETURN ID_ESTADO_BAJA;
    ELSE
        SIGNAL SQLSTATE '20050' SET MESSAGE_TEXT = "ERROR AL BUSCAR EL ESTADO DE TIPO_GESTION, CONTACTE AL DBA";
    END IF;
END// DELIMITER;




/*FUNCIÓN QUE PERMITIRÁ OBTENER EL ID DE LA CLASE DE GESTION PARA HACER EL INSERT DE UN TIPO DE GESTION*/
DROP FUNCTION IF EXISTS FUNCT_EXTRAER_ID_CLASE_GESTION;
DELIMITER //
CREATE FUNCTION FUNCT_EXTRAER_ID_CLASE_GESTION(DESCRIPCION VARCHAR(100)) RETURNS INT(3)
BEGIN 
    DECLARE ID_CLASE INT;
    SET ID_CLASE=(SELECT ID_CLASE_GESTION FROM CLASE_GESTION WHERE NOMBRE=DESCRIPCION LIMIT 1);
    IF(ID_CLASE!='') THEN
        RETURN ID_CLASE;
    ELSE
        SIGNAL SQLSTATE '20054' SET MESSAGE_TEXT="ERROR AL BUSCAR EL ID DE LA CLASE DE GESTION, COMUNIQUESE CON EL DESARROLADOR";

    END IF;
END// DELIMITER;



/*******************************************************************************/
                        /*PROCEDIMIENTOS ALMACENADOS CRUD TIPO_GESTION */
/*******************************************************************************/

/*PROCEDIMIENTO ALMACENADO PARA LA CREACIÓN DE UNA TIPO_GESTION*/
DROP PROCEDURE IF EXISTS PA_CREAR_TIPOGESTION_SISTEMA;
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_CREAR_TIPOGESTION_SISTEMA`(IN NOMBRE_NUEVO VARCHAR(100),IN NOMBRE_CLASE_GESTION VARCHAR(100),IN NIP_ULT_USR_MOD INT,IN NOMBRE_ROL_USR_RESP VARCHAR(100))
BEGIN
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20051' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de creación de TIPO_GESTION";
    END;
    START TRANSACTION;
        /*VERIFICAMOS SI EL USUARIO QUE QUIERE CREAR AL TIPO_GESTION ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            
                /*EVALUAMOS QUE EL ROL EXISTE EN LA BD Y EXTRAEMOS EL ID DE ESTE*/
                SET @NROL_USUARIO_MOD=(SELECT ID_ROL FROM ROL_USUARIO
                WHERE DESCRIPCION=NOMBRE_ROL_USR_RESP LIMIT 1);
                /*SI EL ROL DE USUARIO ES ÚNICAMENTE ADMINISTRADOR*/ 
                IF(@NROL_USUARIO_MOD IN(4)) THEN
                    /*EXTRAEMOS EL ID DE LA CLASE DE GESTION*/
                    SET @ID_CLASE=(SELECT FUNCT_EXTRAER_ID_CLASE_GESTION(NOMBRE_CLASE_GESTION));
                    INSERT TIPO_GESTION(NOMBRE,ID_CLASE_GESTION,ID_ESTADO_TIPO_GESTION,ULTIMO_USUARIO_MODIFICADOR) VALUES(NOMBRE_NUEVO,@ID_CLASE,1,NIP_ULT_USR_MOD);
                ELSE
                SIGNAL SQLSTATE '20052' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
                END IF;
                COMMIT;
        ELSE
            SIGNAL SQLSTATE '20053' SET MESSAGE_TEXT='¡Usted no tiene privilegios de Administrador!';
            ROLLBACK;
        END IF;
END;


select * from tipo_gestion;
/*CALL PA_CREAR_TIPOGESTION_SISTEMA ('prueba','OFICIO',1751,'ADMINISTRADOR');*/






/*procedimiento almacenado para la actualización de datos de una sección*/
DROP PROCEDURE IF EXISTS PA_ACTUALIZAR_TIPOGESTION_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_ACTUALIZAR_TIPOGESTION_SISTEMA`(IN ID_TIPOGESTION_EDITAR INT, IN NOMBRE_TIPOGESTION_EDITAR VARCHAR(100),
IN NOMBRE_CLASE_GESTION_EDITAR VARCHAR(100),IN NIP_ULT_USR_MOD INT,IN NOMBRE_ROL_USR_RESP VARCHAR(100))
BEGIN
    /*variables para capturar los datos recuperados de la bd del tipo de gestión
    a través de un cursor*/
    DECLARE C_ID_TIPOGESTION INT(10);
    DECLARE C_NOMBRE VARCHAR(200);
    DECLARE C_CLASE_GESTION VARCHAR(200);
    DECLARE C_ID_TIPOGESTION_ULT_USR_MODIFICADOR INT(10);
    /*variable para cerrar el loop*/
    DECLARE FIN_LOOP INTEGER DEFAULT 0;
    /*creo un cursor para recuperar los datos del tipo de gestión a actualizar (datos)*/
    DECLARE CURSOR_SELECCION_TIPOGESTION CURSOR FOR
    SELECT ID_TIPO_GESTION,NOMBRE,ID_CLASE_GESTION,ULTIMO_USUARIO_MODIFICADOR
    FROM TIPO_GESTION WHERE ID_TIPO_GESTION=ID_TIPOGESTION_EDITAR;

    /*VARIABLE PARA CONTROLAR EL FINAL DE RECORRIDO DEL CURSOR*/
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIN_LOOP=1; 
    /*excepción para hacer rolback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, SINO
    EN alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20055' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de actualización de tipo de gestión";
    END;

    START TRANSACTION;
        /*OBTENDGO EL ID DE CLASE_GESTION NUEVO A ACTUALIZAR O EL QUE ENVIAN COMO PARAMETRO*/
            SET @ID_CLASE_GEST=(SELECT FUNCT_EXTRAER_ID_CLASE_GESTION(NOMBRE_CLASE_GESTION_EDITAR));

        /*VERIFICAMOS SI EL USUARIO QUE QUIERE EDITAR LA SECCIÓN ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN, LUEGO VALIDAREMOS EL ROL*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_ULT_USR_MOD));
        IF(@PRIVILEGIOS=1) THEN
            /*EVALUAMOS QUE EL ROL EXISTE EN LA BD*/
            SET @NROL_USUARIO=(SELECT ID_ROL FROM ROL_USUARIO 
            WHERE DESCRIPCION=NOMBRE_ROL_USR_RESP LIMIT 1);
            /*SI EL ID DE ROL DE USUARIO SE ENCUENTRA en el de rol DE ADMIN*/ 
            IF(@NROL_USUARIO IN(4)) THEN
                /*abrimos el cursor*/
                OPEN CURSOR_SELECCION_TIPOGESTION;
                    CICLO: LOOP
                    FETCH CURSOR_SELECCION_TIPOGESTION INTO C_ID_TIPOGESTION,C_NOMBRE,C_CLASE_GESTION,
                    C_ID_TIPOGESTION_ULT_USR_MODIFICADOR;
                        /*comprobamos si llegamos al final de los registros obtenidos del cursor*/
                        IF FIN_LOOP = 1 THEN
                            LEAVE CICLO;
                        END IF;
                        /*HARÉ VALIDACIÓN DE CAMPO POR CAMPO PARA IDENTIFICAR SI VARIA EL VALOR ANTIGUO
                        DE CADA UNO CON EL NUEVO ENVIADO POR EL USUARIO DESDE LA VISTA*/
                        /*SI SE ACTUALIZA EL NOMBRE DE TIPO_GESTION*/
                        IF(NOMBRE_TIPOGESTION_EDITAR<>C_NOMBRE) THEN
                            UPDATE TIPO_GESTION SET NOMBRE=NOMBRE_TIPOGESTION_EDITAR WHERE ID_TIPO_GESTION=ID_TIPOGESTION_EDITAR;
                        END IF;
                        /*SI LA CLASE_GESTION ES ACTUALIZADA*/
                        IF(@ID_CLASE_GEST<>C_CLASE_GESTION) THEN
                            UPDATE TIPO_GESTION SET ID_CLASE_GESTION=@ID_CLASE_GEST WHERE ID_TIPO_GESTION=ID_TIPOGESTION_EDITAR;
                        END IF;
                        /*DEBEMOS REGISTAR QUE USUARIO CON PRIVILEGIOS DE ADMIN 
                        FUE EL ÚLITMO EN EDITAR A OTRO USUARIO*/
                        IF(C_ID_TIPOGESTION_ULT_USR_MODIFICADOR<>NIP_ULT_USR_MOD) THEN
                            UPDATE TIPO_GESTION SET ULTIMO_USUARIO_MODIFICADOR=NIP_ULT_USR_MOD
                            WHERE ID_TIPO_GESTION=ID_TIPOGESTION_EDITAR;
                        END IF;         
                    END LOOP CICLO;
                CLOSE CURSOR_SELECCION_TIPOGESTION;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20056' SET MESSAGE_TEXT = 'ROL INEXISTENTE';
            ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20057' SET MESSAGE_TEXT = '¡USTED NO TIENE PRIVILEGIOS PARA RELIZAR ESTAS ACCIONES!';
        END IF;    
END// DELIMITER;

/*call PA_ACTUALIZAR_TIPOGESTION_SISTEMA(11,'PRUEBA 3','OFICIO',1751,'ADMINISTRADOR');*/




/*PROCEDIMIENTO ALMACENAOD PARA DAR DE BAJA A UNA TIPO_GESTION DEL SISTEMA*/
DROP PROCEDURE  IF EXISTS PA_BAJA_TIPOGESTION_SISTEMA;
DELIMITER //
CREATE DEFINER=`root`@`localhost` PROCEDURE `PA_BAJA_TIPOGESTION_SISTEMA`(IN ID_TIPO_GESTION_FIJA INT,IN NIP_USR_RESP INT)
BEGIN
    /*Variable para determinar si el usuario que quiere hacer el UPDATE 
    existe en la bd, y tiene rol de administrador*/
    DECLARE VALIDAR_ROL INT;
    /*Variable para recuperar el id del estado "baja"*/
    DECLARE ID_ESTADO_BAJA INT;
    /*excepción para hacer rolLback si surge una excepción de sql durante la 
    ejecución del procedimiento almacenado (no en algún query como tal, sino
    en alguna fase de compilación del procedimiento almacenado)*/
    DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
        ROLLBACK;
         SIGNAL SQLSTATE '20059' SET MESSAGE_TEXT = "errror durante
         la ejecución del procedimiento de BAJA DEL TIPO_GESTION";
    END;

    START TRANSACTION;
        /*VERIFICAMOS SI EL TIPO_GESTION QUE QUIERE CREAR OTRO ESTÁ ACTIVO Y TENGA PRIVILEGIOS DE ADMIN*/
        SET @PRIVILEGIOS=(SELECT FUNCT_EXISTE_USR_ADMIN(NIP_USR_RESP));
        IF(@PRIVILEGIOS=1) THEN
            /*RECUPERO EL ID DEL ESTADO "BAJA" CON UNA FUNCIÓN*/
            SET ID_ESTADO_BAJA=(SELECT FUNCT_DEVOLVER_ESTADO_TIPOGESTION_BAJA());
            IF(!ISNULL(ID_ESTADO_BAJA)) THEN
                UPDATE TIPO_GESTION SET ID_ESTADO_TIPO_GESTION=ID_ESTADO_BAJA WHERE ID_TIPO_GESTION=ID_TIPO_GESTION_FIJA;
                UPDATE TIPO_GESTION SET ULTIMO_USUARIO_MODIFICADOR=NIP_USR_RESP WHERE ID_TIPO_GESTION=ID_TIPO_GESTION_FIJA;
                COMMIT;
            ELSE
                SIGNAL SQLSTATE '20060' SET MESSAGE_TEXT = "OPCION INEXISTENTE AL QUERER ELIMINAR TIPO_GESTION, COMÚNIQUESE CON EL DESARROLLADOR";
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20061' SET MESSAGE_TEXT="¡Usted no tiene privilegios para realizar esta acción!";
        END IF;
    END// DELIMITER;

/*CALL PA_BAJA_TIPOGESTION_SISTEMA(11,1751);*/




/*******************************************************************************/
                        /*TRIGGERS CRUD TIPO_GESTION */
/*******************************************************************************/

/*TRIGGER PARA REGISTRAR LA CREACIÓN DE UN TIPO_GESTION (INSERCIÓN DE TIPO_GESTION), SOLO 
SE ALMACENA EL "MOVIMIENTO" YA EN LA ACTUALIZACIÓN DE DATOS, SERÁ OTRO TRIGGER
 QUE SE DISPARARÁ*/
DROP TRIGGER IF EXISTS AI_TIPO_GESTION_SISTEMA;
DELIMITER// 
/*Trigger para registar la creación de una nueva sección*/
CREATE DEFINER=`root`@`localhost` TRIGGER AI_TIPO_GESTION_SISTEMA
    AFTER INSERT ON TIPO_GESTION
    FOR EACH ROW
    BEGIN
      INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
      FECHA_MOVIMIENTO,ID_USR_RESPONSABLE)
      VALUES(new.ID_TIPO_GESTION,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR);
  	END// DELIMITER;



/*Trigger para registar la actualización de los datos de un tipo de gestión,
esto se hará después de la actualización de datos de este*/
DROP TRIGGER IF EXISTS AU_TIPO_GESTION_SISTEMA; 
DELIMITER //
CREATE DEFINER=`root`@`localhost` TRIGGER AU_TIPO_GESTION_SISTEMA
AFTER UPDATE ON TIPO_GESTION
FOR EACH ROW
BEGIN 
    /*Variable para capturar el nombre del estado de la sección
    que se está modificando*/    
    DECLARE ESTADO_TIPO_GESTIONN VARCHAR(100);
    /*en las comparaciones adicionales new.variable<>old.variable
    estamos registrando únicamente los movimientos cuando las variables
    son alteradas de valor, es decir, cambian.*/
    IF(NEW.NOMBRE IS NOT NULL AND NEW.NOMBRE<>OLD.NOMBRE) THEN  
            INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_TIPO_GESTION,5,2,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.NOMBRE,new.NOMBRE);

    ELSEIF(NEW.ID_CLASE_GESTION IS NOT NULL AND NEW.ID_CLASE_GESTION<>OLD.ID_CLASE_GESTION) THEN
            INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO) 
            VALUES(new.ID_TIPO_GESTION,5,3,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_CLASE_GESTION,new.ID_CLASE_GESTION);
            
    ELSEIF(NEW.ID_ESTADO_TIPO_GESTION IS NOT NULL AND NEW.ID_ESTADO_TIPO_GESTION<>OLD.ID_ESTADO_TIPO_GESTION) THEN
        /*veo a que valor coincide el nuevo estado de LA TIPO_GESTION*/
        SELECT NOMBRE INTO ESTADO_TIPO_GESTIONN FROM ESTADO_TIPO_GESTION 
        WHERE ID_ESTADO_TIPO_GESTION=NEW.ID_ESTADO_TIPO_GESTION LIMIT 1;
        /*si el tipo de gestión de estar inactivo pasa a activo*/
        IF (ESTADO_TIPO_GESTIONN='ACTIVO') THEN
            INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_TIPO_GESTION,5,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_TIPO_GESTION,new.ID_ESTADO_TIPO_GESTION);        
        /*SI LA TIPO_GESTION PASARÁ A BORRADO, EN LA BITÁCORA REGISTRAMOS QUE EL TIPO DE 
        MOVIMIENTO =6 QUE PERTENECE A "BAJA" DEL SISTEMA (NO ES BORRADO)*/    
        ELSEIF(ESTADO_TIPO_GESTIONN='INACTIVO') THEN
            INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_TIPO_GESTION,5,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_TIPO_GESTION,new.ID_ESTADO_TIPO_GESTION);        
            /*si el tipo de gestión pasa de cualquiera de los dos estados
            anteriores a estado de baja (no será visible más por el usuario, solo por el dba)*/
            ELSEIF(ESTADO_TIPO_GESTIONN='BAJA') THEN
            INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
            ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
            VALUES(new.ID_TIPO_GESTION,6,4,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ID_ESTADO_TIPO_GESTION,new.ID_ESTADO_TIPO_GESTION);        
        END IF;
    /*SOLO REGISTRO EL UDPATE DE ULTIMO USUARIO MODIFICADOR CUANDO CAMBIE, SE ENVIA AL TRIGGER CON
    EL OBJETIVO DE HACER LA INSERCIÓN DEL NIP EN LOS OTROS CAMPOS CUANDO SE NECESITA (REGISTRAR QUE USUARIO HIZO
    EL MOVIMIENTO)*/
    ELSEIF(NEW.ULTIMO_USUARIO_MODIFICADOR IS NOT NULL  AND NEW.ULTIMO_USUARIO_MODIFICADOR<>OLD.ULTIMO_USUARIO_MODIFICADOR) THEN
         INSERT INTO BITACORA_TIPO_GESTION(ID_TIPO_GESTION_AFECTADO,ID_TIPO_MOVIMIENTO,
        ID_CAMPO_AFECTADO,FECHA_MOVIMIENTO,ID_USR_RESPONSABLE,VALOR_ANTERIOR,VALOR_NUEVO)
        VALUES(new.ID_TIPO_GESTION,5,5,NOW(),new.ULTIMO_USUARIO_MODIFICADOR,old.ULTIMO_USUARIO_MODIFICADOR,new.ULTIMO_USUARIO_MODIFICADOR);
    END IF;
END// DELIMITER;


select * from bitacora_tipo_gestion;



/*******************************************************************************/
                        /* CRUD GESTION */
/*******************************************************************************/
/*Este es el módulo principal, en el se harán la mayoria de transaccciones, pues 
básicamente consistirá en la creación de una gestión, actualización de fechas y estados de estos
según lo planteado en las funcionalidades anteriores de clase gestion, estado gestion*/

/*******************************************************************************/
                        /* VISTAS CRUD GESTION */
/*******************************************************************************/

/*VISTA PARA SOLO COLOCAR EL ID DE LA SECCION, ANIO Y CORRELATIVO, A FIN DE HACER MÁS RÁPIDA LA CONSULTA*/

DROP VIEW IF EXISTS VISTA_VERIFICACION_GESTION;
DELIMITER //
CREATE VIEW VISTA_VERIFICACION_GESTION
(SECCION,CORRELATIVO,ANIO)
AS
(   SELECT G.ID_SECCION,G.CORRELATIVO,G.ANIO FROM GESTION G
    INNER JOIN ESTADO_GESTION EG
    ON G.ID_ESTADO_GESTION=EG.ID_ESTADO_GESTION WHERE EG.NOMBRE<>'EVACUACION'
);

// DELIMITER;


/*VISTA GENERAL PARA VER LAS GESTIONES, PERO QUE NO ESTÉN CON ESTADAO DE EVACUADO*/

DROP VIEW IF EXISTS VISTA_CRUD_GESTION;
DELIMITER //
CREATE VIEW VISTA_CRUD_GESTION
(IDEN,ANIO,CORRELATIVO,F_INGRESO,F_TRANSCRIPCION,F_ENTREGA,PERITO_RESPONSABLE,ESTADO,AUXILIAR_ENCARGADO,TIPO_GESTION,NOTAS)
AS
(
    SELECT S.IDENTIFICADOR,G.ANIO,G.CORRELATIVO,IFNULL(DATE_FORMAT(G.FECHA_INGRESO,"%d-%m-%Y"),'PENDIENTE'),
        IFNULL(DATE_FORMAT(G.FECHA_TRANSCRIPCION,'%d-%m-%Y'),'PENDIENTE'),
        IFNULL(DATE_FORMAT(G.FECHA_EGRESO,'%d-%m-%Y'),'PENDIENTE'),
        CONCAT('',P.NOMBRES,' ',P.APELLIDOS) AS NOMBRE_MEDICO,EG.NOMBRE AS ETAPA_TRABAJO,
        CONCAT('',US.NOMBRES,' ',US.APELLIDOS) AS NOMBRE_RESPONSABLE,TG.NOMBRE AS TIPO_GESTION_TRABAJO,G.OBSERVACIONES 
    FROM GESTION G
        INNER JOIN USUARIO_SISTEMA US
            ON G.RESPONSABLE_GESTION=US.ID_USUARIO
        INNER JOIN PERITO P
            ON G.ID_PERITO_RESPONSABLE=P.ID_PERITO
        INNER JOIN SECCION S
            ON G.ID_SECCION=S.ID_SECCION
        INNER JOIN TIPO_GESTION TG
            ON G.ID_TIPO_GESTION=TG.ID_TIPO_GESTION
        INNER JOIN ESTADO_GESTION EG
            ON G.ID_ESTADO_GESTION=EG.ID_ESTADO_GESTION
            WHERE EG.NOMBRE<>'EVACUACION'

);
// DELIMITER; 


/*CREAR UNA VISTA PARA UNIFICAR NOMBRES, APELLIDOS Y ID DE PERITOS*/
/*VISTA PARA UNIR ID, NOMBRES Y APELLIDOS DE USUARIOS*/
/*ESTA VISTA SERVIRÁ PARA RECUPERAR EL ID DEL USUARIO QUE SE LE ATRIBUIRÁ LA GESTION
AL MOMENTO DE CREARLA/EDITAR, SOLO SE MOSTRARAN USUARIOS ACTIVOS */
DROP VIEW IF EXISTS VISTA_UNIFICACION_DATOS_PERITOS;
DELIMITER //
CREATE VIEW VISTA_UNIFICACION_DATOS_PERITOS
    (ID_PERITO,NOMBRE_COMPLETO)
    AS
    ( SELECT P.ID_PERITO,CONCAT('',P.NOMBRES,' ',P.APELLIDOS) AS NOMBRE_MEDICO FROM PERITO P
        INNER JOIN ESTADO_PERITO EP
        ON P.ID_ESTADO_PERITO=EP.ID_ESTADO_PERITO
        WHERE EP.NOMBRE='ACTIVO'
    );
// DELIMITER;


/*ESTA VISTA SERVIRÁ PARA RECUPERAR EL ID DEL PERITO QUE SE LE ATRIBUIRÁ LA GESTION
AL MOMENTO DE CREARLA/EDITAR, SOLO SE MOSTRARAN PERITOS ACTIVOS */
DROP VIEW IF EXISTS VISTA_UNIFICACION_DATOS_USUARIORESP;
DELIMITER //
CREATE VIEW VISTA_UNIFICACION_DATOS_USUARIORESP
    (ID_RESPONSABLE,NOMBRE_COMPLETO)
    AS
    ( SELECT US.ID_USUARIO, CONCAT('',US.NOMBRES,' ',US.APELLIDOS) AS NOMBRE_RESPONSABLE FROM USUARIO_SISTEMA US
        INNER JOIN ESTADO_USUARIO EU
        ON US.ID_ESTADO_USR=EU.ID_ESTADO_USR
        WHERE EU.NOMBRE='ACTIVO'
    );
// DELIMITER;



/*******************************************************************************/
                        /* FUNCIONES CRUD GESTION */
/*******************************************************************************/

/*FUNCION PARA VERIFICAR SI UNA GESTIÒN NO FUE CREADA CON ANTERIORIDAD
RECIBE 3 PARÁMETROS, EL ID DE LA SECCION,EL AÑO Y CORRELATIVO DEVOLVERÁ 1 SINO EXISTE
Y SI EXISTE 0*/
DROP FUNCTION IF EXISTS FUNCT_VERIFICAR_EXISTENCIA_GESTION;
DELIMITER //
CREATE FUNCTION FUNCT_VERIFICAR_EXISTENCIA_GESTION(ID_SECCION_VERIFICAR INT(3),ANIO_VERIFICAR INT(4),CORRELATIVO_VERIFICAR INT(6))
RETURNS INT(03)
BEGIN 
    /*variable para guardar el resultado del count, si devuelve 1 quiere decir que la gestión ya existe*/
    DECLARE RESULTADO_EVALUACION INT(03);
    SET RESULTADO_EVALUACION=(SELECT COUNT(*) FROM VISTA_VERIFICACION_GESTION G WHERE G.ANIO=ANIO_VERIFICAR AND G.CORRELATIVO=CORRELATIVO_VERIFICAR
      AND G.SECCION=ID_SECCION_VERIFICAR);
    IF(RESULTADO_EVALUACION>0) THEN
        RETURN 0;
    ELSE
        RETURN 1;
    END IF;

END // DELIMITER;

SELECT FUNCT_VERIFICAR_EXISTENCIA_GESTION(1,2020,450)

SELECT COUNT(*) FROM VISTA_VERIFICACION_GESTION G WHERE G.CORRELATIVO=450 AND G.ANIO=2020 
        AND G.SECCION=1


/*RECUPERAR EL ID DE LA SECCION EN BASE AL IDENTIFICADOR QUE NOS ENVIEN DESDE EL FRONTEND*/
DROP FUNCTION IF EXISTS FUNCT_OBTENER_ID_SECCION;
DELIMITER//
CREATE FUNCTION FUNCT_OBTENER_ID_SECCION(IDENTIFICADOR_SECCION_NUEVO VARCHAR(10)) RETURNS INT(03)
BEGIN 
    /*VARIABLE PARA ALMACENAR EL RESULTADO DE LA SELECCION DEL ID DE SECCION ACORDE AL IDENTIFICADOR*/
    DECLARE ID_SECCIONN INT(3);
    /*ALMACENO EL RESULTADO, LE COLOCO */
    SET ID_SECCIONN=(SELECT ID_SECCION FROM SECCION SEC WHERE SEC.IDENTIFICADOR=IDENTIFICADOR_SECCION_NUEVO
                    AND SEC.ID_ESTADO_SECCION=(SELECT ID_ESTADO_SECCION FROM ESTADO_SECCION ES WHERE ES.NOMBRE="ACTIVO" LIMIT 1) LIMIT 1);
    
    IF(ID_SECCIONN>0) THEN
        RETURN ID_SECCIONN;
    ELSE
        SIGNAL SQLSTATE '20081' SET MESSAGE_TEXT="ERROR AL EXTRAER EL ID DE SECCION, COMUNÍQUESE CON EL DESARROLLADOR";
    END IF;

END// DELIMITER;
select * from seccion;


/*FUNCION PARA RECUPERAR EL ID DEL PERITO EN BASE AL NOMBRE COMPLETO DE UN PERITO*/
DROP FUNCTION IF EXISTS FUNCT_EXTRAER_ID_PERITO;
DELIMITER//
CREATE FUNCTION FUNCT_EXTRAER_ID_PERITO(NOMBRE_PERITO_RESPONSABLE_NUEVO VARCHAR(200))RETURNS INT(6)
BEGIN 
    /*VARIABLE PARA EXTRAER EL ID DEL PERITO*/
    DECLARE ID_PERITOO INT(06);
    /*BUSCO EN LA VISTA VISTA_UNIFICACION_DATOS_PERITOS PARA RECUPERAR EL ID DEL PERITO,
     VALE LA PENA DESTACAR QUE SI EXISTEN HOMÓNIMOS EN LOS NOMBRES, TOMARÁ AL USUARIO ACTIVO MÁS PROXIMO,
     EL LIMIT LO UTILIZO PARA EVITAR QUE SE EJECUTE UNA EXCEPCIÓN DE TOO MANY ROWS*/
    SET ID_PERITOO=(SELECT ID_PERITO FROM VISTA_UNIFICACION_DATOS_PERITOS 
                    WHERE NOMBRE_COMPLETO=NOMBRE_PERITO_RESPONSABLE_NUEVO LIMIT 1);
    IF(ID_PERITOO>0) THEN
        RETURN ID_PERITOO;
    ELSE
        SIGNAL SQLSTATE '20085' SET MESSAGE_TEXT="HA OCURRIDO UN ERROR, CONTACTE AL DESARROLLADOR";
    END IF;
END// DELIMITER;

/*FUNCION PARA EXTRAER EL ID DEL USUARIO RESPONSABLE SEGÙN EL NOMBRE COMPLETO DE ESTE, SI EXISTEN
HOMÒNIMOS, SE TOMARÀ EL MAS CERCANO, A MENOS QUE A FUTURO SE TOME EL DPI COMO CLAVE DIFERENCIADORA*/
DROP FUNCTION IF EXISTS FUNCT_EXTRAER_ID_USUARIORESP;
DELIMITER//
CREATE FUNCTION FUNCT_EXTRAER_ID_USUARIORESP(NOMBRE_USUARIO_RESPONSABLE_NUEVO VARCHAR(200))RETURNS INT(6)
BEGIN 
    /*VARIABLE PARA EXTRAER EL ID DEL PERITO*/
    DECLARE ID_USUARIOO INT(06);
    /*BUSCO EN LA VISTA VISTA_UNIFICACION_DATOS_USUARIORESP PARA RECUPERAR EL ID DEL PERITO,
     VALE LA PENA DESTACAR QUE SI EXISTEN HOMÓNIMOS EN LOS NOMBRES, TOMARÁ AL USUARIO ACTIVO MÁS PROXIMO,
     EL LIMIT LO UTILIZO PARA EVITAR QUE SE EJECUTE UNA EXCEPCIÓN DE TOO MANY ROWS*/
    SET ID_USUARIOO=(SELECT ID_RESPONSABLE FROM VISTA_UNIFICACION_DATOS_USUARIORESP 
                    WHERE NOMBRE_COMPLETO=NOMBRE_USUARIO_RESPONSABLE_NUEVO LIMIT 1);
    IF(ID_USUARIOO>0) THEN
        RETURN ID_USUARIOO;
    ELSE
        SIGNAL SQLSTATE '20090' SET MESSAGE_TEXT="HA OCURRIDO UN ERROR, CONTACTE AL DESARROLLADOR";
    END IF;
END// DELIMITER;


/*FUNCION PARA EXTRAER EL ID DE GESTION, ÚNICAMENTE SE TOMARÀN LAS QUE TENGAN ESTADO ACTIVO*/
DROP FUNCTION IF EXISTS FUNCT_EXTRAER_ID_TP_GESTION;
DELIMITER //
CREATE FUNCTION FUNCT_EXTRAER_ID_TP_GESTION(NOMBRE_TIPO_GESTION VARCHAR(100)) RETURNS INT(03)
BEGIN 
    /*VARIABLE para almacenar el resultado de la consulta*/
    DECLARE ID_TIPO_GESTIONES INT(03);
    /*BUSCO LOS VALORES Y LOS ASIGNO A LA VARIABLE*/
    SET ID_TIPO_GESTIONES = (SELECT ID_TIPO_GESTION TG FROM TIPO_GESTION TG INNER JOIN
    ESTADO_TIPO_GESTION EG ON
    TG.ID_ESTADO_TIPO_GESTION=EG.ID_ESTADO_TIPO_GESTION WHERE TG.NOMBRE=NOMBRE_TIPO_GESTION AND EG.NOMBRE="ACTIVO" LIMIT 1);
    IF(ID_TIPO_GESTIONES>0) THEN
        RETURN ID_TIPO_GESTIONES;
    ELSE
        SIGNAL SQLSTATE '20087' SET MESSAGE_TEXT="COMUNÍQUESE CON EL DESARROLLADOR";
    END IF;

END// DELIMITER;


/* FUNCION PARA EXTRAER EL ID DE ESTADO DE LA GESTION*/
DROP FUNCTION IF EXISTS FUNCT_EXTRAER_ID_ESTADO_GESTION;
DELIMITER //
CREATE FUNCTION FUNCT_EXTRAER_ID_ESTADO_GESTION(NOMBRE_ESTADO_GESTION VARCHAR(100)) RETURNS INT(03)
BEGIN 
    /*variable para almacenar el resultado de la consulta, vamos a tomar el id del estado de gestion*/
    DECLARE TOMAR_ID_ESTADO_GESTION INT(03);
    /*BUSCO EL ID QUE COINCIDA CON EL NOMBRE DE ESTADO DE GESTION*/
    SET TOMAR_ID_ESTADO_GESTION=(SELECT ID_ESTADO_GESTION FROM ESTADO_GESTION WHERE NOMBRE=NOMBRE_ESTADO_GESTION LIMIT 1);
    IF(TOMAR_ID_ESTADO_GESTION>0) THEN
        RETURN TOMAR_ID_ESTADO_GESTION;
    ELSE
        SIGNAL SQLSTATE '20098' SET MESSAGE_TEXT="No existe un estado con la descripcion dada, contacte al desarrollador";
    END IF;

END;
// DELIMITER;








/*******************************************************************************/
                        /* PROCEDIMIENTOS ALMACENADOS CRUD GESTION */
/*******************************************************************************/

/*CREACION DE GESTION: RECIBIRÉ POR PARTE DEL USUARIO FINAL
LOS SIGUIENTES PARÁMETROS: SECCION(ACRÓNIMO),ANIO,CORRELATIVO,PERITO_RESPONSABLE,FECHA_INGRESO,TIPO_GESTION*/
DROP PROCEDURE IF EXISTS PA_CREAR_GESTION;
DELIMITER //
CREATE PROCEDURE PA_CREAR_GESTION(IN IDENTIFICADOR_SECCION_NUEVO VARCHAR(10),IN ANIO_NUEVO INT,
IN CORRELATIVO_NUEVO INT,NOMBRE_PERITO_RESPONSABLE_NUEVO VARCHAR(200),IN FECHA_INGRESO VARCHAR(20),
NOMBRE_TIPO_GESTION VARCHAR(100),IN NOMBRE_RESPONSABLE_GESTION_NUEVO VARCHAR(200),
IN OBSERVACIONES_NUEVO VARCHAR(600),IN ULTIMO_USUARIO_MODIFICADOR_NUEVO INT)
BEGIN
    /*variables para manipular los datos*/
    DECLARE ID_SECCIONES INT(03);
    /*variable para recuperar el id, según su nombre completo*/
    DECLARE ID_PERITOS INT(06);
    /*variable para hacer validaciones a la fecha, convertirla a tipo date*/
    DECLARE DATO_FECHA_INGRESO DATE;
    /*Variable para extraer el id del tipo de gestion*/
    DECLARE ID_TIPO_GESTIONES INT(03);
    /*Variable para recuperar el id_usuario (NIP) del responsable de la gesiton, debe
    ser un usuario del sistema, en base a sus nombres y apellidos*/
    DECLARE ID_GESTOR INT(06);
    /*VARIABLE PARA DETERMINAR SI UNA GESTION YA EXISTEN EN EL SISTEMA*/
    DECLARE EXISTE_GESTION INT(03);
    
    DECLARE EXIT HANDLER FOR SQLWARNING
        BEGIN
            ROLLBACK;
            SIGNAL SQLSTATE '20080' SET MESSAGE_TEXT = "errror durante
            la ejecución del procedimiento de creación de gestion";
    END;

    START TRANSACTION;
        /*1.-Recupero el id de la seccion en base al identificador que me envien como parámetro*/
        SET ID_SECCIONES=(SELECT FUNCT_OBTENER_ID_SECCION(IDENTIFICADOR_SECCION_NUEVO));
        /*SI NOS DEVUELVE UN ID DE SECCION DENTRO DE LOS PERMITIDOS*/
        IF(ID_SECCIONES>0) THEN
            /*valido que el año de la gestión sea igual al cual va iniciar a funcionar el sistema en adelante,
            es decir, tendrá que ser mayor o igual a 2020, si me mandan decimales, redondeo el numero
            al entero SIN APROXIMAR*/
            IF(SELECT FLOOR(ANIO_NUEVO)>=2020) THEN
                /*VALIDO QUE EL CORRELATIVO QUE ME INGRESEN, SEA MAYOR A 0 DE LO CONTRARIO NOTIFICARÁ EL ERROR*/
                IF(FLOOR(CORRELATIVO_NUEVO)>0) THEN
                    /*VERIFICO SI LA GESTION EXISTE, SI ES ASÍ, LANZARÉ UNA EXCEPCIÓN PARA NOTIFICARLE AL USUARIO FINAL*/
                    /*SI YA EXISTE LA GESTIÓN DEVUELVE 0 Y SE CANCELA LA INSERCIÓN, SINO EXISTE LA GESTION
                    DEVUELVE UN 1*/
                    SET EXISTE_GESTION=(SELECT FUNCT_VERIFICAR_EXISTENCIA_GESTION(ID_SECCIONES,ANIO_NUEVO,CORRELATIVO_NUEVO));
                    IF(EXISTE_GESTION=1) THEN
                        /*RETORNAR EL ID DEL PERITO A CARGO DE LA GESTION*/
                        SET ID_PERITOS=(SELECT FUNCT_EXTRAER_ID_PERITO(NOMBRE_PERITO_RESPONSABLE_NUEVO));
                        /*SI SE EXTRAJO CORRECTAMENTE EL ID DEL PERITO*/
                        IF(ID_PERITOS>0) THEN
                            /*VALIDO LA FECHA DE INGRESO QUE TENGA EL FORMATO CORRECTO,DEBO CONVERTIRLA
                            A FORMATO DATE, EL FORMATO QUE TIENE QUE VENIR ES DE DIA/MES/AÑO */
                            SET DATO_FECHA_INGRESO= STR_TO_DATE(REPLACE(FECHA_INGRESO,'/','-') ,'%d-%m-%Y');
                            /*VERIFICO SI EL AÑO DE LA FECHA ES MAYOR O IGUAL 2020 PARA CONTINUAR CON EL PROCESO*/
                            IF(SELECT YEAR(DATO_FECHA_INGRESO)>=2020) THEN
                                /*SE DEBE EXTARE EL ID DEL TIPO DE GESTION PARA HACER EL INSERT*/
                                SET ID_TIPO_GESTIONES=(SELECT FUNCT_EXTRAER_ID_TP_GESTION(NOMBRE_TIPO_GESTION));
                                IF(ID_TIPO_GESTIONES>0) THEN
                                    /*EXTRAER EL ID DEL USUARIO RESPONSABLE DE TRANSCRIBIR DICTAMEN O ENTREGAR OFICIO(SI APLICA)*/
                                        SET ID_GESTOR=(SELECT FUNCT_EXTRAER_ID_USUARIORESP(NOMBRE_RESPONSABLE_GESTION_NUEVO));
                                        IF(ID_GESTOR>0) THEN
                                            /*PROCEDO A HACER LA INSERCION EN LA TABLA GESTION*/
                                            INSERT INTO GESTION (CORRELATIVO,ANIO,ID_SECCION,ID_PERITO_RESPONSABLE,FECHA_INGRESO,
                                                                        ID_ESTADO_GESTION,ID_TIPO_GESTION,RESPONSABLE_GESTION,OBSERVACIONES,
                                                                        ULTIMO_USUARIO_MODIFICADOR)
                                            VALUES(CORRELATIVO_NUEVO,ANIO_NUEVO,ID_SECCIONES,ID_PERITOS,DATO_FECHA_INGRESO,1,
                                                    ID_TIPO_GESTIONES,ID_GESTOR,OBSERVACIONES_NUEVO,ULTIMO_USUARIO_MODIFICADOR_NUEVO);
                                            /*SE CONFIRMA LA TRANSACCION*/
                                            COMMIT;
                                        ELSE
                                            SIGNAL SQLSTATE '20094' SET MESSAGE_TEXT="EL USUARIO RESPONSABLE NO ESTÁ DISPONIBLE, CONTACTE AL DESARROLLADOR";
                                            ROLLBACK;
                                        END IF;
                                ELSE
                                    SIGNAL SQLSTATE '20088' SET MESSAGE_TEXT="COMUNÍQUESE CON EL DESARROLLADOR,EL TIPO DE GESTION NO EXISTE";
                                    ROLLBACK;
                                END IF;
                            END IF;
                        ELSE
                            SIGNAL SQLSTATE '20086' SET MESSAGE_TEXT="ERROR AL EXTRAER EL ID_PERITO, CONTACTE AL DESARROLLADOR";
                            ROLLBACK;
                        END IF;

                    ELSE
                        SIGNAL SQLSTATE '20095' SET MESSAGE_TEXT="LA GESTION YA EXISTE, SINO LA ENCUENTRA EN LA TABLA, CONTACTE
                        AL ADMINISTRADOR";
                        ROLLBACK;
                    END IF;        
                ELSE
                    SIGNAL SQLSTATE '20084' SET MESSAGE_TEXT="DEBE INGRESAR ÚNICAMENTE NÚMEROS ENTEROS";
                    ROLLBACK;
                END IF;
            ELSE 
                /*le notifico al usuario que está ingresando un año no permitido*/
                SIGNAL SQLSTATE '20083' SET MESSAGE_TEXT="EL AÑO NO PUEDE SER MENOR A 2020, pues a partir de este inició
                a funcionar el sistema, solo se permiten números en ese rango";
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20082' SET MESSAGE_TEXT="Algo salió mal, contacte al desarrollador";
            ROLLBACK;
        END IF;
END;
// DELIMITER;

/*
INSERT INTO GESTION (CORRELATIVO,ANIO,ID_SECCION,ID_PERITO_RESPONSABLE,FECHA_INGRESO,ID_ESTADO_GESTION,ID_TIPO_GESTION,RESPONSABLE_GESTION,OBSERVACIONES,ULTIMO_USUARIO_MODIFICADOR)
VALUES(450,2020,1,2251,STR_TO_DATE(REPLACE('28/02/2020','/','-') ,'%d-%m-%Y'),1,1,1751,'',1751);
*/

/*
CREATE PROCEDURE PA_CREAR_GESTION(IN IDENTIFICADOR_SECCION_NUEVO VARCHAR(10),IN ANIO_NUEVO INT,
IN CORRELATIVO_NUEVO INT,NOMBRE_PERITO_RESPONSABLE_NUEVO VARCHAR(200),IN FECHA_INGRESO VARCHAR(20),
NOMBRE_TIPO_GESTION VARCHAR(100),IN NOMBRE_RESPONSABLE_GESTION_NUEVO VARCHAR(200),
IN OBSERVACIONES_NUEVO VARCHAR(600),IN ULTIMO_USUARIO_MODIFICADOR_NUEVO INT)


call PA_CREAR_GESTION('PCEN',2020,455,'ROSITA CANALES','31/03/2020','NECROPSIA','Walter Giovanni Rivera López','',1751);
*/




/*CREACION DE GESTION: RECIBIRÉ POR PARTE DEL USUARIO FINAL
LOS SIGUIENTES PARÁMETROS: SECCION(ACRÓNIMO),ANIO,CORRELATIVO,PERITO_RESPONSABLE,FECHA_INGRESO,TIPO_GESTION*/
DROP PROCEDURE IF EXISTS PA_EDITAR_GESTION;
DELIMITER //
CREATE PROCEDURE PA_EDITAR_GESTION(IN IDENTIFICADOR_SECCION_EDITAR VARCHAR(10),IN ANIO_EDITAR INT,
IN CORRELATIVO_EDITAR INT,IN NOMBRE_PERITO_RESPONSABLE_EDITAR VARCHAR(200),IN FECHA_INGRESO VARCHAR(20),
IN FECHA_TRANSCRIPCION_EDITAR VARCHAR(20),IN FECHA_ENTREGA_EDITAR VARCHAR(20),IN NOMBRE_ESTADO_GESTION VARCHAR(100),
IN NOMBRE_TIPO_GESTION VARCHAR(100),IN NOMBRE_RESPONSABLE_GESTION_EDITAR VARCHAR(200),
IN OBSERVACIONES_EDITAR VARCHAR(600),IN ULTIMO_USUARIO_MODIFICADOR_EDITAR INT)
BEGIN
    /*variables para manipular los datos*/
    DECLARE ID_SECCIONES INT(03);
    /*variable para recuperar el id, según su nombre completo*/
    DECLARE ID_PERITOS INT(06);
    /*variable para hacer validaciones a la fecha de ingreso, convertirla a tipo date*/
    DECLARE DATO_FECHA_INGRESO DATE;
    /*variable para hacer validacioens a la fecha de transcripcion, convertrila a tipo date*/
    DECLARE DATO_FECHA_TRANSCRIPCION DATE;
    /*variable para hacer validaciones a la fecha de egreso*/
    DECLARE DATO_FECHA_EGRESO DATE;
    /*Variable para extraer el id del tipo de gestion*/
    DECLARE ID_TIPO_GESTIONES INT(03);
    /*Variable para recuperar el id_usuario (NIP) del responsable de la gesiton, debe
    ser un usuario del sistema, en base a sus nombres y apellidos*/
    DECLARE ID_GESTOR INT(06);
    /*Variable para capturar el id del estado de la gestion a actualizar*/
    DECLARE ESTADO_OPR INT(03);

    /*VARIABLES PARA CURSOR*/
     /*variables para capturar los datos recuperados de la bd del usuario
    a través de un cursor*/
    DECLARE C_CORRELATIVO INT(06);
    DECLARE C_ANIO INT(4);
    DECLARE C_ID_SECCION INT(3);
    DECLARE C_ID_PERITO_RESPONSABLE INT(6);
    DECLARE C_FECHA_INGRESO DATE;
    DECLARE C_FECHA_TRANSCRIPCION DATE;
    DECLARE C_FECHA_EGRESO DATE;
    DECLARE C_ID_ESTADO_GESTION INT(3);
    DECLARE C_ID_TIPO_GESTION INT(3);
    DECLARE C_RESPONSABLE_GESTION INT(6);
    DECLARE C_OBSERVACIONES VARCHAR(600);
    DECLARE C_ULTIMO_USUARIO_MODIFICADOR INT(6);

    /*variable para cerrar el loop*/
    DECLARE FIN_LOOP INTEGER DEFAULT 0;

    /*creo un cursor para recuperar los datos del usuario a actualizar (datos)*/
    DECLARE CURSOR_SELECCION_GESTION CURSOR FOR
    SELECT CORRELATIVO,ANIO,ID_SECCION,ID_PERITO_RESPONSABLE,FECHA_INGRESO,FECHA_TRANSCRIPCION,
    FECHA_EGRESO,ID_ESTADO_GESTION,ID_TIPO_GESTION,RESPONSABLE_GESTION,OBSERVACIONES,ULTIMO_USUARIO_MODIFICADOR
    FROM GESTION WHERE ANIO=ANIO_EDITAR AND CORRELATIVO=CORRELATIVO_EDITAR;
    /*VARIABLE PARA CONTROLAR EL FINAL DE RECORRIDO DEL CURSOR*/
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIN_LOOP=1; 


    START TRANSACTION;
        /*1.-Recupero el id de la seccion en base al identificador que me envien como parámetro*/
    SET ID_SECCIONES=(SELECT FUNCT_OBTENER_ID_SECCION(IDENTIFICADOR_SECCION_EDITAR));
        /*SI NOS DEVUELVE UN ID DE SECCION DENTRO DE LOS PERMITIDOS*/
        IF(ID_SECCIONES>0) THEN
            /*valido que el año de la gestión sea igual al cual va iniciar a funcionar el sistema en adelante,
            es decir, tendrá que ser mayor o igual a 2020, si me mandan decimales, redondeo el numero
            al entero SIN APROXIMAR*/
            IF(SELECT FLOOR(ANIO_EDITAR)>=2020) THEN
                /*VALIDO QUE EL CORRELATIVO QUE ME INGRESEN, SEA MAYOR A 0 DE LO CONTRARIO NOTIFICARÁ EL ERROR*/
                IF(FLOOR(CORRELATIVO_EDITAR)>0) THEN
                        /*RETORNAR EL ID DEL PERITO A CARGO DE LA GESTION*/
                        SET ID_PERITOS=(SELECT FUNCT_EXTRAER_ID_PERITO(NOMBRE_PERITO_RESPONSABLE_EDITAR));
                        /*SI SE EXTRAJO CORRECTAMENTE EL ID DEL PERITO*/
                        IF(ID_PERITOS>0) THEN
                            /*VALIDO LA FECHA DE INGRESO QUE TENGA EL FORMATO CORRECTO,DEBO CONVERTIRLA
                            A FORMATO DATE, EL FORMATO QUE TIENE QUE VENIR ES DE DIA/MES/AÑO */
                            SET DATO_FECHA_INGRESO= STR_TO_DATE(REPLACE(FECHA_INGRESO,'/','-') ,'%d-%m-%Y');
                            /*VERIFICO SI EL AÑO DE LA FECHA ES MAYOR O IGUAL 2020 PARA CONTINUAR CON EL PROCESO*/
                            IF(SELECT YEAR(DATO_FECHA_INGRESO)>=2020) THEN
                                /*SE DEBE EXTARE EL ID DEL TIPO DE GESTION PARA HACER EL INSERT*/
                                SET ID_TIPO_GESTIONES=(SELECT FUNCT_EXTRAER_ID_TP_GESTION(NOMBRE_TIPO_GESTION));
                                IF(ID_TIPO_GESTIONES>0) THEN
                                    /*EXTRAER EL ID DEL USUARIO RESPONSABLE DE TRANSCRIBIR DICTAMEN O ENTREGAR OFICIO(SI APLICA)*/
                                        SET ID_GESTOR=(SELECT FUNCT_EXTRAER_ID_USUARIORESP(NOMBRE_RESPONSABLE_GESTION_EDITAR));
                                        IF(ID_GESTOR>0) THEN
                                            /*EXTRAIGO EL ID DEL ESTADO DE LA OPERACION A REALIZAR*/
                                                SET ESTADO_OPR=(SELECT FUNCT_EXTRAER_ID_ESTADO_GESTION(NOMBRE_ESTADO_GESTION));
                                                IF(ESTADO_OPR>0) THEN
                                                    /*PROCEDO A HACER LAS VALIDACIONES PARA ACTUALIZACION*/
                                                    /*abrimos el cursor*/
                                                    OPEN CURSOR_SELECCION_GESTION;
                                                        CICLO: LOOP
                                                        FETCH CURSOR_SELECCION_GESTION INTO C_CORRELATIVO,C_ANIO, C_ID_SECCION,
                                                        C_ID_PERITO_RESPONSABLE,C_FECHA_INGRESO,C_FECHA_TRANSCRIPCION,C_FECHA_EGRESO,
                                                        C_ID_ESTADO_GESTION,C_ID_TIPO_GESTION,C_RESPONSABLE_GESTION,C_OBSERVACIONES,
                                                        C_ULTIMO_USUARIO_MODIFICADOR;
                                                            /*comprobamos si llegamos al final de los registros obtenidos del cursor*/
                                                            IF FIN_LOOP = 1 THEN
                                                                LEAVE CICLO;
                                                            END IF;
                                                            /*HARÉ VALIDACIÓN DE CAMPO POR CAMPO PARA IDENTIFICAR SI VARIA EL VALOR ANTIGUO
                                                            DE CADA UNO CON EL EDITAR ENVIADO POR EL USUARIO DESDE LA VISTA*/
                                                            /*NO SE PERMITIRÁ LA MODIFICACIÓN DE LA SECCION,ANIO Y CORRELATIVO,
                                                            PORQUE SON NUESTRAS LLAVES PRIMARIAS*/
                                                            /*SI EL NOMBRE DEL PERITO RESPONSABLE ES CAMBIADO*/
                                                            IF(C_ID_PERITO_RESPONSABLE<>ID_PERITOS)THEN
                                                                UPDATE GESTION SET ID_PERITO_RESPONSABLE=ID_PERITOS WHERE ANIO=ANIO_EDITAR
                                                                AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            END IF;
                                                            /*SI LA FECHA DE INGRESO ES CAMBIADA*/
                                                            IF(C_FECHA_INGRESO<>DATO_FECHA_INGRESO) THEN
                                                                UPDATE GESTION SET FECHA_INGRESO=DATO_FECHA_INGRESO WHERE ANIO=ANIO_EDITAR
                                                                AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            END IF;
                                                            
                                                            /*SI EL ESTADO DE LA GESTION FUE MODIFICADO*/
                                                            IF(C_ID_ESTADO_GESTION<>ESTADO_OPR) THEN
                                                                UPDATE GESTION SET ID_ESTADO_GESTION=ESTADO_OPR WHERE ANIO=ANIO_EDITAR
                                                                AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            END IF;
                                                            /*SI EL TIPO DE GESTION ES MODIFICADO*/
                                                            IF(C_ID_TIPO_GESTION<>ID_TIPO_GESTIONES)THEN
                                                                UPDATE GESTION SET ID_TIPO_GESTION=ID_TIPO_GESTIONES WHERE ANIO=ANIO_EDITAR
                                                                AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            END IF;
                                                            /*SI EL RESPONSABLE DE LA GESTION ES CAMBIADO*/
                                                            IF(C_RESPONSABLE_GESTION<>ID_GESTOR)THEN
                                                                UPDATE GESTION SET RESPONSABLE_GESTION=ID_GESTOR WHERE ANIO=ANIO_EDITAR
                                                                AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            END IF;
                                                            /*SI LAS OBSERVACIONES CAMBIAN*/
                                                            IF(C_OBSERVACIONES<>OBSERVACIONES_EDITAR)THEN
                                                                UPDATE GESTION SET OBSERVACIONES=OBSERVACIONES_EDITAR WHERE ANIO=ANIO_EDITAR
                                                                AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            END IF;
                                                            /*SI EL USUARIO MODIFICADOR CAMBIA*/
                                                            IF(C_ULTIMO_USUARIO_MODIFICADOR<>ULTIMO_USUARIO_MODIFICADOR_EDITAR)THEN
                                                                UPDATE GESTION SET ULTIMO_USUARIO_MODIFICADOR=ULTIMO_USUARIO_MODIFICADOR_EDITAR
                                                                WHERE ANIO=ANIO_EDITAR AND CORRELATIVO=CORRELATIVO_EDITAR
                                                                AND ID_SECCION=ID_SECCIONES;
                                                            END IF;

                                                            /*SI NOS TRAE VALORES, CONVERTIMOS EL STRING EN FORMATO DE FECHA*/
                                                            /*VALIDO LA FECHA DE INGRESO QUE TENGA EL FORMATO CORRECTO,DEBO CONVERTIRLA
                                                            A FORMATO DATE, EL FORMATO QUE TIENE QUE VENIR ES DE DIA/MES/AÑO */
                                                            SET DATO_FECHA_TRANSCRIPCION= STR_TO_DATE(REPLACE(FECHA_TRANSCRIPCION_EDITAR,'/','-') ,'%d-%m-%Y');
                                                            /*VERIFICO SI EL AÑO DE LA FECHA ES MAYOR O IGUAL 2020 PARA CONTINUAR CON EL PROCESO*/
                                                            IF(SELECT YEAR(DATO_FECHA_TRANSCRIPCION)>=2020) THEN
                                                                    UPDATE GESTION SET FECHA_TRANSCRIPCION=DATO_FECHA_TRANSCRIPCION WHERE ANIO=ANIO_EDITAR
                                                                    AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            ELSE
                                                                SIGNAL SQLSTATE '20110' SET MESSAGE_TEXT="FORMATO DE FECHA DE TRANSCRIPCION INCORRECTO O AÑO MENOR A 2020";
                                                                ROLLBACK;
                                                            END IF;

                                                            /*QUIERE DECIR QUE TRAE DATOS, LOS CONVERTIMOS A FORMATO DE FECHA*/
                                                            SET DATO_FECHA_EGRESO= STR_TO_DATE(REPLACE(FECHA_ENTREGA_EDITAR,'/','-') ,'%d-%m-%Y');
                                                            /*VERIFICO SI EL AÑO DE LA FECHA ES MAYOR O IGUAL 2020 PARA CONTINUAR CON EL PROCESO*/
                                                            IF(SELECT YEAR(DATO_FECHA_EGRESO)>=2020) THEN
                                                                    UPDATE GESTION SET FECHA_EGRESO=DATO_FECHA_EGRESO WHERE ANIO=ANIO_EDITAR
                                                                    AND CORRELATIVO=CORRELATIVO_EDITAR AND ID_SECCION=ID_SECCIONES;
                                                            ELSE
                                                                SIGNAL SQLSTATE '20111' SET MESSAGE_TEXT="FORMATO DE FECHA DE evacuacion/firma/ INCORRECTO O AÑO MENOR A 2020";
                                                                ROLLBACK;
                                                            END IF;
                                                        END LOOP CICLO;
                                                    CLOSE CURSOR_SELECCION_GESTION;
                                                    /*SE CONFIRMAN LAS TRANSACCIONES*/
                                                     COMMIT;
                                                ELSE
                                                    SIGNAL SQLSTATE '20104' SET MESSAGE_TEXT="SECCION INEXISTENTE O DUPLICADA, CONTACTE AL DESARROLLADOR";
                                                    ROLLBACK;
                                                END IF;    
                                        ELSE
                                            SIGNAL SQLSTATE '20103' SET MESSAGE_TEXT="EL USUARIO RESPONSABLE NO ESTÁ DISPONIBLE, CONTACTE AL DESARROLLADOR";
                                            ROLLBACK;
                                        END IF;
                                ELSE
                                    SIGNAL SQLSTATE '20102' SET MESSAGE_TEXT="COMUNÍQUESE CON EL DESARROLLADOR,EL TIPO DE GESTION NO EXISTE";
                                    ROLLBACK;
                                END IF;
                            END IF;
                        ELSE
                            SIGNAL SQLSTATE '20101' SET MESSAGE_TEXT="ERROR AL EXTRAER EL ID_PERITO, CONTACTE AL DESARROLLADOR";
                            ROLLBACK;
                        END IF;       
                ELSE
                    SIGNAL SQLSTATE '20099' SET MESSAGE_TEXT="DEBE INGRESAR ÚNICAMENTE NÚMEROS ENTEROS";
                    ROLLBACK;
                END IF;
            ELSE 
                /*le notifico al usuario que está ingresando un año no permitido*/
                SIGNAL SQLSTATE '20105' SET MESSAGE_TEXT="EL AÑO NO PUEDE SER MENOR A 2020, pues a partir de este inició
                a funcionar el sistema, solo se permiten números en ese rango";
                ROLLBACK;
            END IF;
        ELSE
            SIGNAL SQLSTATE '20106' SET MESSAGE_TEXT="Algo salió mal, contacte al desarrollador";
            ROLLBACK;
        END IF;
END;
// DELIMITER;